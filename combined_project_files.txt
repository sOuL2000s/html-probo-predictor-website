
--- START FILE: backend_app.py ---

# app.py
from flask import Flask, jsonify, request
from flask_cors import CORS
import os
from datetime import datetime, timedelta
import pandas as pd
import pytz
import numpy as np
import requests
import feedparser
from textblob import TextBlob
import urllib.parse
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.trend import EMAIndicator, MACD
from ta.volatility import BollingerBands
from prophet import Prophet

app = Flask(__name__)
CORS(app)

# --- Global Data Storage ---
# Data for Bitcoin
btc_market_data_df = None
btc_current_price = 0.0
btc_sentiment_score = 0.0
btc_market_conditions = {}

# Data for Ethereum
eth_market_data_df = None
eth_current_price = 0.0
eth_sentiment_score = 0.0
eth_market_conditions = {}

# --- Configuration ---
BINANCE_BASE_URL = "https://api.binance.com"
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "YOUR_FALLBACK_TELEGRAM_BOT_TOKEN")
TELEGRAM_USER_ID = os.environ.get("TELEGRAM_USER_ID", 5368095453)

# --- Crypto Data Functions ---

def fetch_ohlcv(symbol="BTCUSDT", interval="1h", limit=150): # Increased limit for better indicator calculation
    """
    Fetches OHLCV (Open, High, Low, Close, Volume) data from Binance for a given symbol.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    
    try:
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        if not data:
            print(f"No data received for {symbol} with interval {interval}.")
            return pd.DataFrame()

        df = pd.DataFrame(data, columns=[
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_buy_base_vol", "taker_buy_quote_vol", "ignore"
        ])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.set_index("timestamp", inplace=True)
        
        for col in ["open", "high", "low", "close", "volume"]:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        
        df.dropna(subset=["open", "high", "low", "close", "volume"], inplace=True)

        return df[["open", "high", "low", "close", "volume"]]
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OHLCV data from Binance for {symbol}: {e}")
        return pd.DataFrame()
    except ValueError as e:
        print(f"Error parsing JSON data from Binance for {symbol}: {e}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in fetch_ohlcv for {symbol}: {e}")
        return pd.DataFrame()

def add_technical_indicators(df):
    """
    Adds RSI, EMA 20, EMA 50, MACD, Stochastic Oscillator, Bollinger Bands,
    and candle volatility metrics to the DataFrame.
    """
    if df.empty or not all(col in df.columns for col in ['open', 'high', 'low', 'close', 'volume']):
        print("DataFrame is empty or missing required OHLCV columns for indicator calculation.")
        return df

    for col in ['open', 'high', 'low', 'close', 'volume']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    df.dropna(subset=['open', 'high', 'low', 'close', 'volume'], inplace=True)

    if df.empty:
        return df

    # Calculate RSI
    if len(df) >= 14:
        rsi = RSIIndicator(df["close"], window=14).rsi()
        df["RSI"] = rsi
    else:
        df["RSI"] = float('nan')

    # Calculate EMA 20
    if len(df) >= 20:
        ema_20 = EMAIndicator(df["close"], window=20).ema_indicator()
        df["EMA_20"] = ema_20
    else:
        df["EMA_20"] = float('nan')

    # Calculate EMA 50
    if len(df) >= 50:
        ema_50 = EMAIndicator(df["close"], window=50).ema_indicator()
        df["EMA_50"] = ema_50
    else:
        df["EMA_50"] = float('nan')

    # Calculate MACD
    if len(df) >= 26: # MACD needs at least 26 periods for EMA calculation
        macd_indicator = MACD(df["close"])
        df["MACD"] = macd_indicator.macd()
        df["MACD_Signal"] = macd_indicator.macd_signal()
        df["MACD_Hist"] = macd_indicator.macd_diff()
    else:
        df["MACD"] = float('nan')
        df["MACD_Signal"] = float('nan')
        df["MACD_Hist"] = float('nan')

    # Calculate Stochastic Oscillator
    if len(df) >= 14: # Stochastic needs at least 14 periods
        stoch_indicator = StochasticOscillator(df["high"], df["low"], df["close"])
        df["STOCH_K"] = stoch_indicator.stoch()
        df["STOCH_D"] = stoch_indicator.stoch_signal()
    else:
        df["STOCH_K"] = float('nan')
        df["STOCH_D"] = float('nan')

    # Calculate Bollinger Bands
    if len(df) >= 20: # Bollinger Bands typically use 20 periods
        bb_indicator = BollingerBands(df["close"])
        df["BB_Upper"] = bb_indicator.bollinger_hband()
        df["BB_Lower"] = bb_indicator.bollinger_lband()
        df["BB_Mid"] = bb_indicator.bollinger_mavg()
        df["BB_Width"] = bb_indicator.bollinger_wband()
        df["BB_Percent"] = bb_indicator.bollinger_pband() # %B
    else:
        df["BB_Upper"] = float('nan')
        df["BB_Lower"] = float('nan')
        df["BB_Mid"] = float('nan')
        df["BB_Width"] = float('nan')
        df["BB_Percent"] = float('nan')

    # Candle Volatility Metrics
    df['body_size'] = abs(df['close'] - df['open'])
    df['candle_range'] = df['high'] - df['low']
    df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
    df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']
    df['total_wick_size'] = df['upper_wick'] + df['lower_wick']

    df['wick_to_body_ratio'] = df.apply(
        lambda row: row['total_wick_size'] / row['body_size'] if row['body_size'] > 0 else (1.0 if row['total_wick_size'] > 0 else 0.0),
        axis=1
    )
    return df

def get_current_price(symbol="BTCUSDT"):
    """
    Fetches the current price of a given symbol from Binance.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/ticker/price?symbol={symbol}"
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return float(response.json()["price"])
    except requests.exceptions.RequestException as e:
        print(f"Error fetching current price for {symbol} from Binance: {e}")
        return 0.0
    except (ValueError, KeyError) as e:
        print(f"Error parsing current price data for {symbol}: {e}")
        return 0.0
    except Exception as e:
        print(f"An unexpected error occurred in get_current_price for {symbol}: {e}")
        return 0.0

# --- Sentiment Functions ---

def fetch_news_sentiment(query="bitcoin", max_items=20):
    """
    Fetches news headlines for a given query from Google News RSS and calculates
    an average sentiment polarity using TextBlob.
    """
    encoded_query = urllib.parse.quote(query)
    url = f"https://news.google.com/rss/search?q={encoded_query}"
    
    try:
        feed = feedparser.parse(url)
        headlines = [entry.title for entry in feed.entries[:max_items]]

        if not headlines:
            print(f"No news headlines found for query: '{query}'")
            return 0.0

        sentiments = [TextBlob(headline).sentiment.polarity for headline in headlines]
        return round(sum(sentiments) / len(sentiments), 3)
    except Exception as e:
        print(f"Error fetching or analyzing news sentiment for '{query}': {e}")
        return 0.0

def get_crypto_sentiment(crypto_name="bitcoin"):
    """
    Gets the sentiment score for a specific cryptocurrency.
    """
    return fetch_news_sentiment(f"{crypto_name} OR {crypto_name[:3].upper()}")

# --- Probo Strategy Functions ---

def interpret_market_conditions(df: pd.DataFrame):
    """
    Interprets market conditions based on technical indicators and volatility metrics.
    Incorporates RSI, EMA, MACD, Stochastic, Bollinger Bands, and candle volatility.
    """
    required_cols = [
        'RSI', 'EMA_20', 'EMA_50', 'MACD', 'MACD_Signal', 'MACD_Hist',
        'STOCH_K', 'STOCH_D', 'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent',
        'body_size', 'candle_range', 'wick_to_body_ratio', 'close', 'volume'
    ]
    if df.empty or not all(col in df.columns for col in required_cols):
        print("Warning: DataFrame is empty or missing required columns for market interpretation. Returning default conditions.")
        return {
            "bullish_trend": False, "oversold": False, "overbought": False,
            "rsi": 50.0, "ema_20": 0.0, "ema_50": 0.0,
            "macd": 0.0, "macd_signal": 0.0, "macd_hist": 0.0,
            "stoch_k": 50.0, "stoch_d": 50.0,
            "bb_upper": 0.0, "bb_lower": 0.0, "bb_mid": 0.0, "bb_width": 0.0, "bb_percent": 0.0,
            "massive_move_recent": False, "candle_volatility_high": False, "candle_bodies_stable": False,
            "macd_bullish_crossover": False, "macd_bearish_crossover": False,
            "stoch_oversold": False, "stoch_overbought": False,
            "price_near_bb_lower": False, "price_near_bb_upper": False,
            "bb_contracting": False, "bb_expanding": False, # New BB states
            "volume_spike_recent": False # New volume analysis
        }

    latest = df.iloc[-1]

    # Extract values, handling potential NaN
    rsi = float(latest["RSI"]) if pd.notna(latest["RSI"]) else None
    ema_20 = float(latest["EMA_20"]) if pd.notna(latest["EMA_20"]) else None
    ema_50 = float(latest["EMA_50"]) if pd.notna(latest["EMA_50"]) else None
    macd = float(latest["MACD"]) if pd.notna(latest["MACD"]) else None
    macd_signal = float(latest["MACD_Signal"]) if pd.notna(latest["MACD_Signal"]) else None
    macd_hist = float(latest["MACD_Hist"]) if pd.notna(latest["MACD_Hist"]) else None
    stoch_k = float(latest["STOCH_K"]) if pd.notna(latest["STOCH_K"]) else None
    stoch_d = float(latest["STOCH_D"]) if pd.notna(latest["STOCH_D"]) else None
    bb_upper = float(latest["BB_Upper"]) if pd.notna(latest["BB_Upper"]) else None
    bb_lower = float(latest["BB_Lower"]) if pd.notna(latest["BB_Lower"]) else None
    bb_width = float(latest["BB_Width"]) if pd.notna(latest["BB_Width"]) else None
    bb_percent = float(latest["BB_Percent"]) if pd.notna(latest["BB_Percent"]) else None
    latest_close = float(latest["close"]) if pd.notna(latest["close"]) else None
    latest_body_size = float(latest["body_size"]) if pd.notna(latest["body_size"]) else None
    latest_candle_range = float(latest["candle_range"]) if pd.notna(latest["candle_range"]) else None
    latest_wick_to_body_ratio = float(latest["wick_to_body_ratio"]) if pd.notna(latest["wick_to_body_ratio"]) else None
    latest_volume = float(latest["volume"]) if pd.notna(latest["volume"]) else None

    # Trend and Momentum
    bullish_trend = bool(ema_20 is not None and ema_50 is not None and ema_20 > ema_50)
    rsi_oversold = bool(rsi is not None and rsi < 30)
    rsi_overbought = bool(rsi is not None and rsi > 70)
    
    macd_bullish_crossover = bool(macd is not None and macd_signal is not None and macd > macd_signal and macd_hist > 0)
    macd_bearish_crossover = bool(macd is not None and macd_signal is not None and macd < macd_signal and macd_hist < 0)

    stoch_oversold = bool(stoch_k is not None and stoch_d is not None and stoch_k < 20 and stoch_d < 20)
    stoch_overbought = bool(stoch_k is not None and stoch_d is not None and stoch_k > 80 and stoch_d > 80)

    # Volatility and Price Action
    massive_move_recent = False
    if len(df) >= 4 and latest_close is not None:
        past_close = df['close'].iloc[-4] if len(df) >= 4 else df['close'].iloc[0]
        if pd.notna(past_close) and past_close != 0:
            percent_change = abs((latest_close - past_close) / past_close) * 100
            if percent_change > 2.0:
                massive_move_recent = True

    candle_volatility_high = False
    candle_bodies_stable = False
    if latest_wick_to_body_ratio is not None and latest_body_size is not None and latest_candle_range is not None and latest_close is not None:
        if latest_wick_to_body_ratio > 1.5 or (latest_candle_range / latest_close) * 100 > 1.0:
            candle_volatility_high = True
        if latest_wick_to_body_ratio < 0.5 and (latest_body_size / latest_close) * 100 > 0.1:
            candle_bodies_stable = True
    if candle_volatility_high:
        candle_bodies_stable = False

    # Bollinger Band interpretations
    price_near_bb_lower = bool(latest_close is not None and bb_lower is not None and latest_close <= bb_lower * 1.005) # Within 0.5% of lower band
    price_near_bb_upper = bool(latest_close is not None and bb_upper is not None and latest_close >= bb_upper * 0.995) # Within 0.5% of upper band
    
    bb_contracting = False
    bb_expanding = False
    if len(df) >= 20 and bb_width is not None:
        # Check if current BB width is significantly smaller/larger than average of last few widths
        # Use a rolling average of BB_Width to detect contraction/expansion
        rolling_bb_width_avg = df['BB_Width'].iloc[-20:].mean() # Average of last 20 widths
        if rolling_bb_width_avg is not None and rolling_bb_width_avg > 0:
            if bb_width < rolling_bb_width_avg * 0.9: # 10% narrower than recent average
                bb_contracting = True
            elif bb_width > rolling_bb_width_avg * 1.1: # 10% wider than recent average
                bb_expanding = True

    # Volume Analysis: Check for significant volume spikes
    volume_spike_recent = False
    if len(df) >= 10 and latest_volume is not None:
        avg_volume_past = df['volume'].iloc[-10:-1].mean() # Average of last 9 volumes
        if avg_volume_past is not None and avg_volume_past > 0:
            if latest_volume > avg_volume_past * 1.5: # Current volume is 50% higher than recent average
                volume_spike_recent = True


    return {
        "bullish_trend": bullish_trend,
        "oversold": rsi_oversold,
        "overbought": rsi_overbought,
        "rsi": rsi,
        "ema_20": ema_20,
        "ema_50": ema_50,
        "macd": macd,
        "macd_signal": macd_signal,
        "macd_hist": macd_hist,
        "stoch_k": stoch_k,
        "stoch_d": stoch_d,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "bb_mid": latest["BB_Mid"] if pd.notna(latest["BB_Mid"]) else None,
        "bb_width": bb_width,
        "bb_percent": bb_percent,
        "massive_move_recent": massive_move_recent,
        "candle_volatility_high": candle_volatility_high,
        "candle_bodies_stable": candle_bodies_stable,
        "macd_bullish_crossover": macd_bullish_crossover,
        "macd_bearish_crossover": macd_bearish_crossover,
        "stoch_oversold": stoch_oversold,
        "stoch_overbought": stoch_overbought,
        "price_near_bb_lower": price_near_bb_lower,
        "price_near_bb_upper": price_near_bb_upper,
        "bb_contracting": bb_contracting,
        "bb_expanding": bb_expanding,
        "volume_spike_recent": volume_spike_recent
    }

# --- Predictor Functions ---

def predict_future_price(df: pd.DataFrame, current_price: float, hours_ahead: float = 1):
    """
    Predicts the future price using Facebook Prophet.
    """
    if df.empty or 'close' not in df.columns or len(df) < 50: # Increased minimum data points for Prophet
        print("Warning: Not enough data in DataFrame for accurate Prophet prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    prophet_df = df.reset_index()[['timestamp', 'close']].rename(columns={'timestamp': 'ds', 'close': 'y'})
    prophet_df['y'] = pd.to_numeric(prophet_df['y'], errors='coerce')
    prophet_df.dropna(subset=['y'], inplace=True)

    if prophet_df.empty or len(prophet_df) < 50:
        print("Warning: 'close' column has insufficient numeric data for Prophet prediction after cleaning. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Initialize and fit Prophet model with adjusted parameters
    model = Prophet(
        daily_seasonality=True,
        weekly_seasonality=False,
        yearly_seasonality=False,
        changepoint_prior_scale=0.08 # Increased flexibility for trend changes
    )
    try:
        model.fit(prophet_df)
    except Exception as e:
        print(f"Error fitting Prophet model: {e}. Returning current price as projected.")
        return current_price, 0.0, current_price

    future = model.make_future_dataframe(periods=int(hours_ahead), freq='H')
    forecast = model.predict(future)
    projected_price = forecast['yhat'].iloc[-1]

    last_known_price = prophet_df['y'].iloc[-1]
    total_predicted_change = projected_price - last_known_price
    avg_delta = total_predicted_change / hours_ahead if hours_ahead > 0 else 0.0

    projected_price = max(0.0, projected_price)

    return round(projected_price, 2), round(avg_delta, 2), current_price


def recommend_probo_vote_for_target(df: pd.DataFrame, current_price: float, sentiment_score: float, target_price: float, target_time_str: str):
    """
    Recommends a 'YES' or 'NO' vote for a Probo outcome based on projected price and sentiment.
    """
    now_utc = datetime.utcnow()
    target_time_only = datetime.strptime(target_time_str, "%H:%M").time()
    target_datetime_utc = now_utc.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)
    
    if target_datetime_utc < now_utc:
        target_datetime_utc += timedelta(days=1)

    hours_remaining = (target_datetime_utc - now_utc).total_seconds() / 3600
    hours_remaining = max(0.25, round(hours_remaining, 2))

    sentiment = sentiment_score
    projected, delta, current = predict_future_price(df, current_price, hours_remaining)

    if projected >= target_price and sentiment >= -0.1:
        vote = "YES"
    else:
        vote = "NO"

    result = {
        "current_price": current,
        "avg_delta_per_hour": delta,
        "hours_remaining": hours_remaining,
        "projected_price": projected,
        "sentiment": sentiment,
        "target_price": target_price,
        "target_time": target_time_str,
        "vote": vote
    }
    return result

# --- Telegram Bot Functions ---

def send_telegram_alert(message):
    """
    Sends a Markdown-formatted message as an alert to a specified Telegram user.
    """
    if not TELEGRAM_BOT_TOKEN or TELEGRAM_BOT_TOKEN == "YOUR_FALLBACK_TELEGRAM_BOT_TOKEN":
        print("❌ Telegram BOT_TOKEN not configured. Alert not sent. Please set the TELEGRAM_BOT_TOKEN environment variable.")
        return
    
    if not TELEGRAM_USER_ID:
        print("❌ Telegram USER_ID not configured. Alert not sent. Please set the TELEGRAM_USER_ID environment variable.")
        return

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_USER_ID,
        "text": message,
        "parse_mode": "Markdown"
    }
    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()
        if response.status_code == 200:
            print("✅ Telegram alert sent successfully.")
        else:
            print(f"❌ Failed to send alert (status code: {response.status_code}): {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"❌ Telegram alert error (network/request issue): {str(e)}")
    except Exception as e:
        print(f"❌ An unexpected error occurred while sending Telegram alert: {str(e)}")

# --- Flask App Endpoints ---

def load_initial_data():
    """Fetches and processes initial market data and sentiment for both BTC and ETH."""
    global btc_market_data_df, btc_current_price, btc_sentiment_score, btc_market_conditions
    global eth_market_data_df, eth_current_price, eth_sentiment_score, eth_market_conditions

    # --- Load BTC Data ---
    try:
        print("Fetching BTC OHLCV data...")
        df_btc = fetch_ohlcv(symbol="BTCUSDT", limit=200) # Increased limit for better indicator calculation
        if df_btc.empty:
            print("Failed to fetch BTC OHLCV data. Setting defaults.")
            btc_market_data_df = pd.DataFrame()
            btc_current_price = 0.0
            btc_sentiment_score = 0.0
            btc_market_conditions = {
                "bullish_trend": False, "oversold": False, "overbought": False,
                "rsi": 50.0, "ema_20": 0.0, "ema_50": 0.0,
                "macd": 0.0, "macd_signal": 0.0, "macd_hist": 0.0,
                "stoch_k": 50.0, "stoch_d": 50.0,
                "bb_upper": 0.0, "bb_lower": 0.0, "bb_mid": 0.0, "bb_width": 0.0, "bb_percent": 0.0,
                "massive_move_recent": False, "candle_volatility_high": False, "candle_bodies_stable": False,
                "macd_bullish_crossover": False, "macd_bearish_crossover": False,
                "stoch_oversold": False, "stoch_overbought": False,
                "price_near_bb_lower": False, "price_near_bb_upper": False,
                "bb_contracting": False, "bb_expanding": False,
                "volume_spike_recent": False
            }
        else:
            print("Adding technical indicators for BTC...")
            df_btc = add_technical_indicators(df_btc)
            btc_market_data_df = df_btc

            print("Getting current BTC price...")
            btc_current_price = get_current_price(symbol="BTCUSDT")

            print("Getting Bitcoin sentiment...")
            btc_sentiment_score = get_crypto_sentiment(crypto_name="bitcoin")

            print("Interpreting BTC market conditions...")
            btc_market_conditions = interpret_market_conditions(btc_market_data_df)
            print("BTC Data loaded successfully.")
    except Exception as e:
        print(f"Error loading initial BTC data: {e}")
        btc_market_data_df = pd.DataFrame()
        btc_current_price = 0.0
        btc_sentiment_score = 0.0
        btc_market_conditions = {
            "bullish_trend": False, "oversold": False, "overbought": False,
            "rsi": 50.0, "ema_20": 0.0, "ema_50": 0.0,
            "macd": 0.0, "macd_signal": 0.0, "macd_hist": 0.0,
            "stoch_k": 50.0, "stoch_d": 50.0,
            "bb_upper": 0.0, "bb_lower": 0.0, "bb_mid": 0.0, "bb_width": 0.0, "bb_percent": 0.0,
            "massive_move_recent": False, "candle_volatility_high": False, "candle_bodies_stable": False,
            "macd_bullish_crossover": False, "macd_bearish_crossover": False,
            "stoch_oversold": False, "stoch_overbought": False,
            "price_near_bb_lower": False, "price_near_bb_upper": False,
            "bb_contracting": False, "bb_expanding": False,
            "volume_spike_recent": False
        }

    # --- Load ETH Data ---
    try:
        print("Fetching ETH OHLCV data...")
        df_eth = fetch_ohlcv(symbol="ETHUSDT", limit=200) # Increased limit
        if df_eth.empty:
            print("Failed to fetch ETH OHLCV data. Setting defaults.")
            eth_market_data_df = pd.DataFrame()
            eth_current_price = 0.0
            eth_sentiment_score = 0.0
            eth_market_conditions = {
                "bullish_trend": False, "oversold": False, "overbought": False,
                "rsi": 50.0, "ema_20": 0.0, "ema_50": 0.0,
                "macd": 0.0, "macd_signal": 0.0, "macd_hist": 0.0,
                "stoch_k": 50.0, "stoch_d": 50.0,
                "bb_upper": 0.0, "bb_lower": 0.0, "bb_mid": 0.0, "bb_width": 0.0, "bb_percent": 0.0,
                "massive_move_recent": False, "candle_volatility_high": False, "candle_bodies_stable": False,
                "macd_bullish_crossover": False, "macd_bearish_crossover": False,
                "stoch_oversold": False, "stoch_overbought": False,
                "price_near_bb_lower": False, "price_near_bb_upper": False,
                "bb_contracting": False, "bb_expanding": False,
                "volume_spike_recent": False
            }
        else:
            print("Adding technical indicators for ETH...")
            df_eth = add_technical_indicators(df_eth)
            eth_market_data_df = df_eth

            print("Getting current ETH price...")
            eth_current_price = get_current_price(symbol="ETHUSDT")

            print("Getting Ethereum sentiment...")
            eth_sentiment_score = get_crypto_sentiment(crypto_name="ethereum")

            print("Interpreting ETH market conditions...")
            eth_market_conditions = interpret_market_conditions(df_eth)
            print("ETH Data loaded successfully.")
    except Exception as e:
        print(f"Error loading initial ETH data: {e}")
        eth_market_data_df = pd.DataFrame()
        eth_current_price = 0.0
        eth_sentiment_score = 0.0
        eth_market_conditions = {
            "bullish_trend": False, "oversold": False, "overbought": False,
            "rsi": 50.0, "ema_20": 0.0, "ema_50": 0.0,
            "macd": 0.0, "macd_signal": 0.0, "macd_hist": 0.0,
            "stoch_k": 50.0, "stoch_d": 50.0,
            "bb_upper": 0.0, "bb_lower": 0.0, "bb_mid": 0.0, "bb_width": 0.0, "bb_percent": 0.0,
            "massive_move_recent": False, "candle_volatility_high": False, "candle_bodies_stable": False,
            "macd_bullish_crossover": False, "macd_bearish_crossover": False,
            "stoch_oversold": False, "stoch_overbought": False,
            "price_near_bb_lower": False, "price_near_bb_upper": False,
            "bb_contracting": False, "bb_expanding": False,
            "volume_spike_recent": False
        }

# Load data when the Flask app starts
with app.app_context():
    load_initial_data()

@app.route('/api/market_data', methods=['GET'])
def get_market_data():
    """Returns current market data for both BTC and ETH."""
    load_initial_data() # Always refresh data for real-time feel

    response_data = {
        "BTC": {
            "current_price": btc_current_price,
            "sentiment_score": btc_sentiment_score,
            "market_conditions": btc_market_conditions,
            "chart_data": []
        },
        "ETH": {
            "current_price": eth_current_price,
            "sentiment_score": eth_sentiment_score,
            "market_conditions": eth_market_conditions,
            "chart_data": []
        }
    }

    # Convert BTC DataFrame to JSON serializable format
    if btc_market_data_df is not None and not btc_market_data_df.empty:
        chart_data_btc = btc_market_data_df[[
            'open', 'high', 'low', 'close', 'volume', 'EMA_20', 'EMA_50',
            'MACD', 'MACD_Signal', 'MACD_Hist', 'STOCH_K', 'STOCH_D',
            'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent'
        ]].reset_index()
        chart_data_btc = chart_data_btc.replace({np.nan: None})
        response_data["BTC"]["chart_data"] = chart_data_btc.to_dict(orient='records')
        for item in response_data["BTC"]["chart_data"]:
            item['timestamp'] = item['timestamp'].isoformat() if pd.notna(item['timestamp']) else None
    else:
        print("BTC market data not available for chart.")

    # Convert ETH DataFrame to JSON serializable format
    if eth_market_data_df is not None and not eth_market_data_df.empty:
        chart_data_eth = eth_market_data_df[[
            'open', 'high', 'low', 'close', 'volume', 'EMA_20', 'EMA_50',
            'MACD', 'MACD_Signal', 'MACD_Hist', 'STOCH_K', 'STOCH_D',
            'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent'
        ]].reset_index()
        chart_data_eth = chart_data_eth.replace({np.nan: None})
        response_data["ETH"]["chart_data"] = chart_data_eth.to_dict(orient='records')
        for item in response_data["ETH"]["chart_data"]:
            item['timestamp'] = item['timestamp'].isoformat() if pd.notna(item['timestamp']) else None
    else:
        print("ETH market data not available for chart.")

    return jsonify(response_data)

@app.route('/api/predict', methods=['POST'])
def predict_outcome():
    """Performs prediction for the selected cryptocurrency and sends a Telegram alert."""
    data = request.get_json()
    target_price = data.get('target_price')
    target_time_str = data.get('target_time') # HH:MM in IST
    currency = data.get('currency', 'BTC').upper() # Default to BTC if not specified

    if not target_price or not target_time_str or currency not in ['BTC', 'ETH']:
        return jsonify({"error": "Missing target_price, target_time, or invalid currency"}), 400

    load_initial_data() # Ensure market data is loaded and fresh

    df_to_use = None
    current_price_to_use = 0.0
    sentiment_to_use = 0.0
    market_conditions_to_use = {}
    crypto_name_full = ""

    if currency == 'BTC':
        df_to_use = btc_market_data_df
        current_price_to_use = btc_current_price
        sentiment_to_use = btc_sentiment_score
        market_conditions_to_use = btc_market_conditions
        crypto_name_full = "Bitcoin"
    elif currency == 'ETH':
        df_to_use = eth_market_data_df
        current_price_to_use = eth_current_price
        sentiment_to_use = eth_sentiment_score
        market_conditions_to_use = eth_market_conditions
        crypto_name_full = "Ethereum"

    if df_to_use is None or df_to_use.empty:
        return jsonify({"error": f"Market data not available for {currency} prediction"}), 500

    try:
        ist_timezone = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist_timezone)
        target_time_only = datetime.strptime(target_time_str, "%H:%M").time()
        target_datetime_ist = now_ist.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)

        if target_datetime_ist < now_ist:
            target_datetime_ist += timedelta(days=1)

        target_datetime_utc = target_datetime_ist.astimezone(pytz.utc)
        hours_remaining = (target_datetime_utc - datetime.utcnow().replace(tzinfo=pytz.utc)).total_seconds() / 3600
        hours_remaining = max(0.25, round(hours_remaining, 2))

        result = recommend_probo_vote_for_target(
            df=df_to_use,
            current_price=current_price_to_use,
            sentiment_score=sentiment_to_use,
            target_price=target_price,
            target_time_str=target_datetime_utc.strftime("%H:%M")
        )
        result['hours_remaining'] = hours_remaining
        result['target_time'] = target_time_str # Keep original IST string for frontend display
        result['currency'] = currency # Add currency to result

        trust_signals = 0
        caution_flags = 0

        hours_remaining_float = result['hours_remaining']
        sentiment_score = result['sentiment']

        # Retrieve stoch_k and stoch_d from market_conditions_to_use
        stoch_k = market_conditions_to_use.get('stoch_k')
        stoch_d = market_conditions_to_use.get('stoch_d')

        # Evaluate Trust Conditions (Total 12 signals now)
        if hours_remaining_float < 2: trust_signals += 1
        if market_conditions_to_use['bullish_trend'] and not market_conditions_to_use['macd_bearish_crossover']: trust_signals += 1 # Stronger trend check
        if abs(sentiment_score) > 0.2: trust_signals += 1
        if market_conditions_to_use['rsi'] is not None and 30 <= market_conditions_to_use['rsi'] <= 70: trust_signals += 1
        if abs(sentiment_score) > 0.05 and not market_conditions_to_use['volume_spike_recent']: trust_signals += 1 # No major news expected, and no sudden volume
        if market_conditions_to_use['candle_bodies_stable'] and not market_conditions_to_use['candle_volatility_high']: trust_signals += 1 # Stable candles, not highly volatile
        if market_conditions_to_use['macd_bullish_crossover'] and market_conditions_to_use['macd_hist'] > 0: trust_signals += 1 # Confirmed MACD bullish crossover
        if market_conditions_to_use['stoch_oversold'] and not market_conditions_to_use['stoch_overbought'] and (stoch_k is not None and stoch_d is not None and stoch_k > stoch_d): trust_signals += 1 # Stochastic oversold with bullish cross
        if market_conditions_to_use['price_near_bb_lower'] and not market_conditions_to_use['bb_contracting'] and not market_conditions_to_use['bb_expanding']: trust_signals += 1 # Price near lower BB, not in squeeze/expansion
        if not market_conditions_to_use['massive_move_recent']: trust_signals += 1 # No massive recent moves (predictability)
        if not market_conditions_to_use['bb_contracting'] and not market_conditions_to_use['bb_expanding']: trust_signals += 1 # Stable Bollinger Bands
        if not market_conditions_to_use['volume_spike_recent']: trust_signals += 1 # No recent volume spike (less unpredictable)


        # Evaluate Caution Conditions (Total 12 flags now)
        if hours_remaining_float > 3: caution_flags += 1
        if market_conditions_to_use['overbought'] or market_conditions_to_use['oversold']: caution_flags += 1
        if abs(sentiment_score) < 0.05: caution_flags += 1
        if market_conditions_to_use['massive_move_recent']: caution_flags += 1
        if abs(sentiment_score) < 0.05 or market_conditions_to_use['volume_spike_recent']: caution_flags += 1 # Big news coming or sudden volume
        if market_conditions_to_use['candle_volatility_high']: caution_flags += 1
        if market_conditions_to_use['macd_bearish_crossover'] and market_conditions_to_use['macd_hist'] < 0: caution_flags += 1 # Confirmed MACD bearish crossover
        if market_conditions_to_use['stoch_overbought'] and not market_conditions_to_use['stoch_oversold'] and (stoch_k is not None and stoch_d is not None and stoch_k < stoch_d): caution_flags += 1 # Stochastic overbought with bearish cross
        if market_conditions_to_use['price_near_bb_upper'] or market_conditions_to_use['bb_contracting'] or market_conditions_to_use['bb_expanding']: caution_flags += 1 # Price near upper BB or BB in squeeze/expansion
        if market_conditions_to_use['bb_contracting'] or market_conditions_to_use['bb_expanding']: caution_flags += 1 # Bollinger Bands squeezing or expanding
        if market_conditions_to_use['volume_spike_recent']: caution_flags += 1 # Recent volume spike (unpredictability)


        # Update total counts for advice message (now 12 for both trust and caution)
        if trust_signals >= 7 and caution_flags < 4: # Adjusted thresholds for more signals
            advice_message = "🔐 Confidence: *GO with the vote!* (Trust: {}/12, Caution: {}/12)".format(trust_signals, caution_flags)
        elif caution_flags >= 4: # Adjusted thresholds
            advice_message = "🔐 Confidence: *SKIP the trade or WAIT!* (Trust: {}/12, Caution: {}/12)".format(trust_signals, caution_flags)
        else:
            advice_message = "🔐 Confidence: *Proceed with caution or wait for clearer signals.* (Trust: {}/12, Caution: {}/12)".format(trust_signals, caution_flags)

        result['confidence_advisor'] = {
            'trust_signals_count': trust_signals,
            'caution_flags_count': caution_flags,
            'advice_message': advice_message,
            'trust_conditions': {
                'time_expiry_lt_2hr': hours_remaining_float < 2,
                'trending_cleanly': bool(market_conditions_to_use['bullish_trend'] and not market_conditions_to_use['macd_bearish_crossover']),
                'sentiment_strong': abs(sentiment_score) > 0.2,
                'rsi_neutral': bool(market_conditions_to_use['rsi'] is not None and 30 <= market_conditions_to_use['rsi'] <= 70),
                'no_major_news_expected_no_volume_spike': abs(sentiment_score) > 0.05 and not market_conditions_to_use['volume_spike_recent'],
                'candle_bodies_stable_not_volatile': market_conditions_to_use['candle_bodies_stable'] and not market_conditions_to_use['candle_volatility_high'],
                'macd_bullish_crossover_confirmed': market_conditions_to_use['macd_bullish_crossover'] and market_conditions_to_use['macd_hist'] > 0,
                'stoch_oversold_bullish_cross': market_conditions_to_use['stoch_oversold'] and not market_conditions_to_use['stoch_overbought'] and (stoch_k is not None and stoch_d is not None and stoch_k > stoch_d),
                'price_near_bb_lower_stable_bands': market_conditions_to_use['price_near_bb_lower'] and not market_conditions_to_use['bb_contracting'] and not market_conditions_to_use['bb_expanding'],
                'no_massive_move_recent': not market_conditions_to_use['massive_move_recent'],
                'bb_stable': not market_conditions_to_use['bb_contracting'] and not market_conditions_to_use['bb_expanding'],
                'no_volume_spike_recent': not market_conditions_to_use['volume_spike_recent']
            },
            'caution_conditions': {
                'target_time_gt_3hr': hours_remaining_float > 3,
                'rsi_extreme': bool(market_conditions_to_use['overbought'] or market_conditions_to_use['oversold']),
                'sentiment_conflicting': abs(sentiment_score) < 0.05,
                'btc_massive_move': market_conditions_to_use['massive_move_recent'],
                'big_news_coming_or_volume_spike': abs(sentiment_score) < 0.05 or market_conditions_to_use['volume_spike_recent'],
                'candle_volatility_high': market_conditions_to_use['candle_volatility_high'],
                'macd_bearish_crossover_confirmed': market_conditions_to_use['macd_bearish_crossover'] and market_conditions_to_use['macd_hist'] < 0,
                'stoch_overbought_bearish_cross': market_conditions_to_use['stoch_overbought'] and not market_conditions_to_use['stoch_oversold'] and (stoch_k is not None and stoch_d is not None and stoch_k < stoch_d),
                'price_near_bb_upper_or_bb_volatile': market_conditions_to_use['price_near_bb_upper'] or market_conditions_to_use['bb_contracting'] or market_conditions_to_use['bb_expanding'],
                'bb_volatile': market_conditions_to_use['bb_contracting'] or market_conditions_to_use['bb_expanding'],
                'volume_spike_recent': market_conditions_to_use['volume_spike_recent']
            }
        }

        alert_message = (
            f"📣 *{currency} Probo Vote Recommendation*\n"
            f"🕒 Target Time (IST): *{target_time_str}*\n"
            f"🎯 Target Price: *${result['target_price']}*\n"
            f"💰 Current: *${result['current_price']:.2f}*\n"
            f"📈 Projected: *${result['projected_price']:.2f}*\n"
            f"💬 Sentiment: *{result['sentiment']:.2f}*\n"
            f"✅ Vote: *{result['vote']}*\n"
            f"\n--- Confidence Advisor ---\n"
            f"{advice_message}"
        )
        send_telegram_alert(alert_message)

        return jsonify(result)
    except ValueError as ve:
        return jsonify({"error": f"Invalid input or time format: {ve}"}), 400
    except Exception as e:
        print(f"An error occurred during prediction: {e}")
        return jsonify({"error": f"An internal server error occurred during prediction: {e}"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)


--- END FILE: backend_app.py ---

--- START FILE: btc_data.py ---

# btc_data.py

import requests
import pandas as pd
import time
from ta.momentum import RSIIndicator
from ta.trend import EMAIndicator

BINANCE_BASE_URL = "https://api.binance.com"

def fetch_ohlcv(symbol="BTCUSDT", interval="1h", limit=100):
    """
    Fetches OHLCV (Open, High, Low, Close, Volume) data from Binance.

    Args:
        symbol (str): The trading pair symbol (e.g., "BTCUSDT").
        interval (str): The candlestick interval (e.g., "1h", "4h", "1d").
        limit (int): The number of data points to fetch.

    Returns:
        pandas.DataFrame: DataFrame containing OHLCV data with timestamp as index.
                          Returns an empty DataFrame on failure.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    
    try:
        response = requests.get(url, params=params, timeout=10) # Add timeout
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        data = response.json()

        if not data:
            print(f"No data received for {symbol} with interval {interval}.")
            return pd.DataFrame()

        df = pd.DataFrame(data, columns=[
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_buy_base_vol", "taker_buy_quote_vol", "ignore"
        ])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.set_index("timestamp", inplace=True)
        # Convert relevant columns to numeric, coercing errors to NaN
        df["open"] = pd.to_numeric(df["open"], errors='coerce')
        df["high"] = pd.to_numeric(df["high"], errors='coerce')
        df["low"] = pd.to_numeric(df["low"], errors='coerce')
        df["close"] = pd.to_numeric(df["close"], errors='coerce')
        df["volume"] = pd.to_numeric(df["volume"], errors='coerce')
        
        # Drop rows with any NaN values that resulted from coercion
        df.dropna(subset=["open", "high", "low", "close", "volume"], inplace=True)

        return df[["open", "high", "low", "close", "volume"]]
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OHLCV data from Binance: {e}")
        return pd.DataFrame()
    except ValueError as e:
        print(f"Error parsing JSON data from Binance: {e}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in fetch_ohlcv: {e}")
        return pd.DataFrame()

def add_technical_indicators(df):
    """
    Adds Relative Strength Index (RSI), EMA 20, and EMA 50 to the DataFrame.
    Also adds candle body size and wick ratio for volatility analysis.

    Args:
        df (pandas.DataFrame): DataFrame with 'close' prices.

    Returns:
        pandas.DataFrame: DataFrame with added technical indicator columns.
    """
    if df.empty or 'close' not in df.columns or 'open' not in df.columns or 'high' not in df.columns or 'low' not in df.columns:
        print("DataFrame is empty or missing required OHLCV columns for indicator calculation.")
        return df

    # Ensure relevant columns are numeric
    for col in ['open', 'high', 'low', 'close']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    df.dropna(subset=['open', 'high', 'low', 'close'], inplace=True)

    if df.empty:
        return df

    # Calculate RSI
    if len(df) >= 14:
        rsi = RSIIndicator(df["close"], window=14).rsi()
        df["RSI"] = rsi
    else:
        df["RSI"] = float('nan')

    # Calculate EMA 20
    if len(df) >= 20:
        ema_20 = EMAIndicator(df["close"], window=20).ema_indicator()
        df["EMA_20"] = ema_20
    else:
        df["EMA_20"] = float('nan')

    # Calculate EMA 50
    if len(df) >= 50:
        ema_50 = EMAIndicator(df["close"], window=50).ema_indicator()
        df["EMA_50"] = ema_50
    else:
        df["EMA_50"] = float('nan')

    # --- New: Candle Volatility Metrics ---
    # Candle body size (absolute difference between open and close)
    df['body_size'] = abs(df['close'] - df['open'])

    # Total candle range (High - Low)
    df['candle_range'] = df['high'] - df['low']

    # Upper wick: High - max(Open, Close)
    df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
    # Lower wick: min(Open, Close) - Low
    df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']

    # Total wick size
    df['total_wick_size'] = df['upper_wick'] + df['lower_wick']

    # Wick to body ratio (avoid division by zero)
    df['wick_to_body_ratio'] = df.apply(
        lambda row: row['total_wick_size'] / row['body_size'] if row['body_size'] > 0 else (1.0 if row['total_wick_size'] > 0 else 0.0),
        axis=1
    )
    # --- End New Metrics ---

    return df

def get_current_price(symbol="BTCUSDT"):
    """
    Fetches the current price of a given symbol from Binance.

    Args:
        symbol (str): The trading pair symbol (e.g., "BTCUSDT").

    Returns:
        float: The current price. Returns 0.0 on failure.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/ticker/price?symbol={symbol}"
    try:
        response = requests.get(url, timeout=5) # Add timeout
        response.raise_for_status()
        return float(response.json()["price"])
    except requests.exceptions.RequestException as e:
        print(f"Error fetching current price from Binance: {e}")
        return 0.0
    except (ValueError, KeyError) as e:
        print(f"Error parsing current price data: {e}")
        return 0.0
    except Exception as e:
        print(f"An unexpected error occurred in get_current_price: {e}")
        return 0.0

if __name__ == "__main__":
    print("--- Testing btc_data.py ---")
    df = fetch_ohlcv()
    if not df.empty:
        df = add_technical_indicators(df)
        print("\nLast 5 OHLCV with Indicators and Volatility Metrics:")
        print(df[['close', 'RSI', 'EMA_20', 'EMA_50', 'body_size', 'candle_range', 'wick_to_body_ratio']].tail())
    else:
        print("Failed to fetch OHLCV data for testing.")

    current_price = get_current_price()
    print(f"\nCurrent BTC Price: ${current_price}")



--- END FILE: btc_data.py ---

--- START FILE: combine_project.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combine_project.py ---

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Probo Predictor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Plotly.js CDN for charting -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Favicon links (ensure these files are in your root directory) -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico"> <!-- Generic favicon -->

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background */
            color: #DAA520; /* Goldenrod text for general content */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            overflow-y: auto; /* Allow scrolling */
        }
        .container {
            background-color: #1a1a1a; /* Slightly lighter black for container */
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 800px; /* Max width for desktop */
            margin: 1rem; /* Margin for mobile and desktop */
            box-sizing: border-box;
        }
        h1, h2, h3, h4 {
            color: #FFD700; /* Gold for headings */
        }
        input[type="number"], input[type="time"], button, select {
            background-color: #222222; /* Darker grey for inputs */
            border: 1px solid #444444; /* Darker grey border */
            color: #FFD700; /* Gold text */
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
        }
        input[type="number"]:focus, input[type="time"]:focus, button:focus, select:focus {
            outline: none;
            border-color: #FFD700; /* Gold border on focus */
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3); /* Gold shadow on focus */
        }
        button {
            cursor: pointer;
            font-weight: 600;
            background-color: #FFD700; /* Gold button */
            border-color: #FFD700;
            color: #000000; /* Black text on gold button */
            display: flex; /* Enable flex for icon and text alignment */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
        }
        button:hover {
            background-color: #DAA520; /* Darker gold on hover */
            border-color: #DAA520;
        }
        .metric-value {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            color: #FFD700; /* Gold */
        }
        .expander-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            font-weight: 600;
            color: #DAA520; /* Goldenrod */
            border-bottom: 1px solid #444444;
            transition: background-color 0.2s ease-in-out; /* Smooth hover */
        }
        .expander-header:hover {
            background-color: #222222; /* Darker grey on hover */
            border-radius: 0.5rem; /* Apply border-radius on hover */
        }
        .expander-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 0 1rem;
        }
        .expander-content.expanded {
            max-height: 9999px;
            padding: 1rem;
        }
        .arrow {
            transition: transform 0.3s ease-out;
        }
        .arrow.expanded {
            transform: rotate(90deg);
        }
        .plotly-graph-div {
            border-radius: 0.75rem;
            overflow: hidden;
            background-color: #222222; /* Darker background for chart area */
        }
        .plotly .modebar {
            background-color: #222222 !important;
            border-radius: 0.5rem;
            padding: 0.25rem;
        }
        .plotly .modebar-btn {
            color: #FFD700 !important;
        }
        .plotly .modebar-btn:hover {
            background-color: #444444 !important;
        }
        /* Custom message boxes for gold/black theme */
        .success-message {
            background-color: #2a3620; /* Darker green */
            color: #d4edda; /* Lighter green */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .warning-message {
            background-color: #4d3a20; /* Darker orange */
            color: #fce8d4; /* Lighter orange */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .info-message {
            background-color: #20364d; /* Darker blue */
            color: #d4e8fc; /* Lighter blue */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .error-message {
            background-color: #4d2020; /* Darker red */
            color: #fcd4d4; /* Lighter red */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #FFD700; /* Gold */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Text colors for YES/NO in confidence advisor */
        .text-green-400 { color: #9ae6b4; } /* Adjusted green for better contrast */
        .text-red-400 { color: #feb2b2; } /* Adjusted red for better contrast */
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6">
            <i class="fas fa-chart-line text-gold-500 mr-3"></i> Crypto Probo Predictor
        </h1>

        <!-- Currency Selector -->
        <div class="bg-gray-900 p-4 rounded-lg shadow-md mb-6 flex flex-col md:flex-row justify-between items-center">
            <span class="text-xl font-medium text-gray-400 mb-2 md:mb-0">
                <i class="fas fa-coins text-gold-300 mr-2"></i> Select Cryptocurrency:
            </span>
            <div class="flex space-x-4">
                <label class="inline-flex items-center">
                    <input type="radio" class="form-radio text-yellow-500" name="currency" value="BTC" checked>
                    <span class="ml-2 text-gold-300"><i class="fab fa-btc mr-1"></i> Bitcoin (BTC)</span>
                </label>
                <label class="inline-flex items-center">
                    <input type="radio" class="form-radio text-yellow-500" name="currency" value="ETH">
                    <span class="ml-2 text-gold-300"><i class="fab fa-ethereum mr-1"></i> Ethereum (ETH)</span>
                </label>
            </div>
        </div>

        <!-- Current Price Metric -->
        <div class="bg-gray-900 p-4 rounded-lg shadow-md mb-6 flex justify-between items-center">
            <span class="text-xl font-medium text-gray-400">
                <i class="fas fa-sack-dollar text-gold-300 mr-2"></i> Current Price (<span id="current-currency-symbol">BTC</span>)
            </span>
            <span id="current-price-display" class="metric-value">$0.00</span>
            <div id="loading-spinner" class="loader hidden"></div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Prediction Form -->
        <h2 class="text-2xl font-semibold mb-4 text-gold-100">
            <i class="fas fa-crystal-ball text-gold-500 mr-2"></i> Predict Probo Outcome
        </h2>
        <form id="prediction-form" class="space-y-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="target-price" class="block text-sm font-medium text-gray-400 mb-1">Target Price (USDT)</label>
                    <input type="number" id="target-price" value="65000" class="w-full rounded-lg px-4 py-2" step="any">
                </div>
                <div>
                    <label for="target-time" class="block text-sm font-medium text-gray-400 mb-1">Target Time (HH:MM in IST)</label>
                    <input type="time" id="target-time" value="23:00" class="w-full rounded-lg px-4 py-2">
                    <p class="text-xs text-gray-500 mt-1">Current IST: <span id="current-ist-time"></span></p>
                </div>
            </div>
            <button type="submit" class="w-full py-2 rounded-lg text-black font-semibold">
                Get Recommendation <div id="prediction-spinner" class="loader hidden"></div>
            </button>
        </form>

        <div id="prediction-results" class="mt-6 space-y-4">
            <!-- Prediction Summary -->
            <div id="prediction-summary-expander" class="expander-header rounded-lg px-4 py-3 bg-gray-900 hover:bg-gray-800 transition-colors duration-200">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-chart-pie text-gold-300 mr-2"></i> Prediction Summary
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="prediction-summary-content" class="expander-content bg-gray-900 rounded-lg">
                <div class="p-4">
                    <p class="text-gold-300"><strong class="text-gold-100">Current Price:</strong> <span id="summary-current-price">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Avg Δ/hr:</strong> <span id="summary-avg-delta">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Time Left:</strong> <span id="summary-time-left">0 hr(s)</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Projected Price:</strong> <span id="summary-projected-price">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Sentiment Score:</strong> <span id="summary-sentiment-score">0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Target Time (IST):</strong> <span id="summary-target-time">HH:MM</span></p>
                </div>
            </div>

            <!-- Recommended Vote -->
            <div id="recommended-vote-message" class="hidden"></div>

            <!-- Prediction Confidence Advisor -->
            <hr class="border-gray-800 my-6">
            <h3 class="text-xl font-semibold text-gold-100">
                <i class="fas fa-lightbulb text-gold-500 mr-2"></i> Prediction Confidence Advisor
            </h3>

            <div id="trust-signals-expander" class="expander-header rounded-lg px-4 py-3 bg-gray-900 hover:bg-gray-800 transition-colors duration-200">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-shield-alt text-green-400 mr-2"></i> Trust Signals
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="trust-signals-content" class="expander-content bg-gray-900 rounded-lg">
                <ul class="list-disc list-inside text-gold-300 space-y-1 p-4">
                    <li>Time to expiry is &lt; 2 hours: <span id="trust-time"></span></li>
                    <li><span id="trust-trend-text">BTC</span> is trending cleanly (up or down): <span id="trust-trend"></span></li>
                    <li>Sentiment score is strongly positive/negative (&gt;0.2): <span id="trust-sentiment"></span></li>
                    <li>RSI is not extreme (30-70): <span id="trust-rsi"></span></li>
                    <li>No major news expected: <span id="trust-news"></span></li>
                    <li>Candle bodies are stable (not huge wicks): <span id="trust-stable-candles"></span></li>
                    <li>MACD shows bullish crossover: <span id="trust-macd-bullish"></span></li>
                    <li>Stochastic is oversold (potential rebound): <span id="trust-stoch-oversold"></span></li>
                    <li>Price near lower Bollinger Band (potential support): <span id="trust-bb-lower"></span></li>
                    <li>No massive move recently: <span id="trust-no-massive-move"></span></li>
                    <li>Bollinger Bands are stable (not squeezing/expanding): <span id="trust-bb-stable"></span></li>
                    <li>No recent volume spike: <span id="trust-no-volume-spike"></span></li>
                </ul>
            </div>

            <div id="caution-flags-expander" class="expander-header rounded-lg px-4 py-3 bg-gray-900 hover:bg-gray-800 transition-colors duration-200">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-2"></i> Caution Flags
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="caution-flags-content" class="expander-content bg-gray-900 rounded-lg">
                <ul class="list-disc list-inside text-gold-300 space-y-1 p-4">
                    <li>Target time is &gt; 3 hours away: <span id="caution-time"></span></li>
                    <li><span id="caution-massive-move-text">BTC</span> just made a massive move: <span id="caution-massive-move"></span></li>
                    <li>RSI is &gt; 75 or &lt; 25: <span id="caution-rsi"></span></li>
                    <li>Sentiment is conflicting (score ≈ 0): <span id="caution-sentiment"></span></li>
                    <li>Big news coming (Fed rate hike, CPI data): <span id="caution-big-news"></span></li>
                    <li>Candle volatility is high (huge wicks): <span id="caution-volatile-candles"></span></li>
                    <li>MACD shows bearish crossover: <span id="caution-macd-bearish"></span></li>
                    <li>Stochastic is overbought (potential reversal): <span id="caution-stoch-overbought"></span></li>
                    <li>Price near upper Bollinger Band or BB contracting: <span id="caution-bb-upper-contracting"></span></li>
                    <li>Bollinger Bands are volatile (squeezing/expanding): <span id="caution-bb-volatile"></span></li>
                    <li>Recent volume spike: <span id="caution-volume-spike"></span></li>
                </ul>
            </div>

            <hr class="border-gray-800 my-6">
            <p class="text-gold-300"><strong class="text-gold-100">Total Trust Signals Met:</strong> <span id="total-trust-signals">0</span></p>
            <p class="text-gold-300"><strong class="text-gold-100">Total Caution Flags Present:</strong> <span id="total-caution-flags">0</span></p>
            <div id="pro-tip-message" class="mt-4"></div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Technical Indicators -->
        <div id="technical-indicators-expander" class="expander-header rounded-lg px-4 py-3 bg-gray-900 hover:bg-gray-800 transition-colors duration-200">
            <span class="text-lg text-gold-100">
                <i class="fas fa-flask text-gold-300 mr-2"></i> Technical Indicators
            </span>
            <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
        </div>
        <div id="technical-indicators-content" class="expander-content bg-gray-900 rounded-lg">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center p-4">
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">RSI</div>
                    <div id="metric-rsi" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">EMA 20</div>
                    <div id="metric-ema20" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">EMA 50</div>
                    <div id="metric-ema50" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">MACD</div>
                    <div id="metric-macd" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">Stoch %K</div>
                    <div id="metric-stochk" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">Stoch %D</div>
                    <div id="metric-stochd" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg col-span-1 md:col-span-3">
                    <div class="text-sm text-gray-400">Bollinger Bands (Upper/Mid/Lower)</div>
                    <div id="metric-bb" class="text-xl font-bold text-gold-300">0.00 / 0.00 / 0.00</div>
                </div>
            </div>
            <div class="mt-4 text-gold-300 p-4 pt-0">
                <p><strong class="text-gold-100">Trend:</strong> <span id="market-trend"></span></p>
                <p><strong class="text-gold-100">RSI Zone:</strong> <span id="market-rsi-zone"></span></p>
                <p><strong class="text-gold-100">Stochastic Zone:</strong> <span id="market-stoch-zone"></span></p>
                <p><strong class="text-gold-100">Bollinger Band Width:</strong> <span id="metric-bb-width"></span></p>
            </div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Chart -->
        <div id="chart-expander" class="expander-header rounded-lg px-4 py-3 bg-gray-900 hover:bg-gray-800 transition-colors duration-200">
            <span class="text-lg text-gold-100">
                <i class="fas fa-chart-area text-gold-300 mr-2"></i> View Chart
            </span>
            <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
        </div>
        <div id="chart-content" class="expander-content bg-gray-900 rounded-lg">
            <div id="candlestick-chart" class="w-full h-[600px] p-4"></div> <!-- Increased height for multiple subplots -->
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Cheat Sheet Reference -->
        <h2 class="text-2xl font-semibold mb-4 text-gold-100">
            <i class="fas fa-book-open text-gold-500 mr-2"></i> Crypto Probo Prediction Cheat Sheet Reference
        </h2>
        <p class="text-gold-400 mb-4">This section provides the original guidelines for reference, updated with new indicators.</p>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">✅ TRUST the Prediction When:</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li><strong>Condition</strong>: Time to expiry is &lt; 2 hours
                <ul><li><strong>Why</strong>: Short-term moves are easier to project with recent trend/sentiment</li></ul>
            </li>
            <li><strong>Condition</strong>: BTC is trending cleanly (up or down)
                <ul><li><strong>Why</strong>: EMA crossover + delta will align clearly</li></ul>
            </li>
            <li><strong>Condition</strong>: Sentiment score is strongly positive/negative (&gt;0.2)
                <ul><li><strong>Why</strong>: Clear market direction from sentiment</li></ul>
            </li>
            <li><strong>Condition</strong>: RSI is not extreme (30–70)
                <ul><li><strong>Why</strong>: Means no strong mean-reversion counterforces</li></ul>
            </li>
            <li><strong>Condition</strong>: No major news expected
                <ul><li><strong>Why</strong>: Market moves more "technically" in news-free windows</li></ul>
            </li>
            <li><strong>Condition</strong>: Candle bodies are stable (not huge wicks)
                <ul><li><strong>Why</strong>: Less noise = better delta prediction accuracy</li></ul>
            </li>
            <li><strong>Condition</strong>: MACD shows bullish crossover
                <ul><li><strong>Why</strong>: Indicates strengthening upward momentum</li></ul>
            </li>
            <li><strong>Condition</strong>: Stochastic is oversold (potential rebound)
                <ul><li><strong>Why</strong>: Price may be due for an upward correction</li></ul>
            </li>
            <li><strong>Condition</strong>: Price near lower Bollinger Band (potential support)
                <ul><li><strong>Why</strong>: Suggests price is at a strong support level</li></ul>
            </li>
            <li><strong>Condition</strong>: No massive move recently
                <ul><li><strong>Why</strong>: Predictable price action</li></ul>
            </li>
            <li><strong>Condition</strong>: Bollinger Bands are stable (not squeezing/expanding)
                <ul><li><strong>Why</strong>: Less volatility uncertainty</li></ul>
            </li>
            <li><strong>Condition</strong>: No recent volume spike
                <ul><li><strong>Why</strong>: Market not reacting to sudden news/events</li></ul>
            </li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">⚠️ BE CAUTIOUS / DOUBLE-CHECK When:</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li><strong>Red Flag</strong>: Target time is &gt; 3 hours away
                <ul><li><strong>Why</strong>: Market conditions may shift unpredictably</li></ul>
            </li>
            <li><strong>Red Flag</strong>: BTC just made a massive move
                <ul><li><strong>Why</strong>: Mean reversion likely → momentum may reverse</li></ul>
            </li>
            <li><strong>Red Flag</strong>: RSI is &gt; 75 or &lt; 25
                <ul><li><strong>Why</strong>: Overbought/oversold zones are prone to reversals</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Sentiment is conflicting (score ≈ 0)
                <ul><li><strong>Why</strong>: Market indecisive — avoid betting</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Big news coming (Fed rate hike, CPI data)
                <ul><li><strong>Why</strong>: Trends and sentiment can break instantly</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Candle volatility is high (huge wicks)
                <ul><li><strong>Why</strong>: Delta estimates become noisy and inaccurate</li></ul>
            </li>
            <li><strong>Red Flag</strong>: MACD shows bearish crossover
                <ul><li><strong>Why</strong>: Indicates strengthening downward momentum</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Stochastic is overbought (potential reversal)
                <ul><li><strong>Why</b>: Price may be due for a downward correction</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Price near upper Bollinger Band or BB contracting
                <ul><li><strong>Why</strong>: Suggests strong resistance or potential for volatile breakout</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Bollinger Bands are volatile (squeezing/expanding)
                <ul><li><strong>Why</strong>: High uncertainty, potential for sharp moves</li></ul>
            </li>
            <li><strong>Red Flag</strong>: Recent volume spike
                <ul><li><strong>Why</strong>: Market reacting to sudden news/events, unpredictable</li></ul>
            </li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">🔐 Pro Tip (Original Reference):</h3>
        <p class="text-gold-300 mb-2">If at least 7/12 “Trust” signals align → GO with the vote.</p>
        <p class="text-gold-300 mb-4">If 4+ “Caution” flags are present → SKIP the trade or wait.</p>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">✅ Example: When to TRUST (Original Reference)</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li>Time: 1 hour left</li>
            <li>BTC uptrending</li>
            <li>EMA20 &gt; EMA50</li>
            <li>RSI = 58</li>
            <li>Sentiment = +0.3</li>
            <li>MACD bullish crossover</li>
            <li>Stochastic not extreme</li>
            <li>Price not near BB extremes</li>
            <li>No massive move recently</li>
            <li>BB stable</li>
            <li>No recent volume spike</li>
            <li>→ ✅ Trust YES vote</li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">⚠️ Example: When to AVOID (Original Reference)</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li>Time: 4 hours left</li>
            <li>BTC dumped $800 in 15 mins</li>
            <li>RSI = 22</li>
            <li>Sentiment = 0.05</li>
            <li>MACD bearish crossover</li>
            <li>Stochastic overbought</li>
            <li>Price near upper BB</li>
            <li>BB squeezing</li>
            <li>Recent volume spike</li>
            <li>→ ⚠️ Avoid vote — unpredictable zone</li>
        </ul>

    </div>

    <script>
        // Helper function to toggle expander sections
        function setupExpander(headerId, contentId) {
            const header = document.getElementById(headerId);
            const content = document.getElementById(contentId);
            const arrow = header.querySelector('.arrow');

            header.addEventListener('click', () => {
                const isExpanded = content.classList.contains('expanded');
                if (isExpanded) {
                    content.classList.remove('expanded');
                    arrow.classList.remove('expanded');
                } else {
                    content.classList.add('expanded');
                    arrow.classList.add('expanded');
                }
            });
        }

        // Setup all expanders
        document.addEventListener('DOMContentLoaded', () => {
            setupExpander('prediction-summary-expander', 'prediction-summary-content');
            setupExpander('technical-indicators-expander', 'technical-indicators-content');
            setupExpander('chart-expander', 'chart-content');
            setupExpander('trust-signals-expander', 'trust-signals-content');
            setupExpander('caution-flags-expander', 'caution-flags-content');
        });

        // --- Backend API URL ---
        const BACKEND_API_URL = 'https://html-probo-predictor-website.onrender.com'; // IMPORTANT: Change this for deployment!

        // Global data storage for both BTC and ETH
        let allMarketData = {
            BTC: { current_price: 0.0, sentiment_score: 0.0, market_conditions: {}, chart_data: [] },
            ETH: { current_price: 0.0, sentiment_score: 0.0, market_conditions: {}, chart_data: [] }
        };
        let selectedCurrency = 'BTC'; // Default selected currency

        // --- UI Update Functions ---

        function updateUI(currencyData, predictionResult = null) {
            const { current_price, sentiment_score, market_conditions, chart_data } = currencyData;

            // Update currency symbol display
            document.getElementById('current-currency-symbol').textContent = selectedCurrency;

            // Update Current Price Metric
            document.getElementById('current-price-display').textContent = `$${current_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

            // Update Technical Indicators
            document.getElementById('metric-rsi').textContent = market_conditions.rsi ? market_conditions.rsi.toFixed(2) : 'N/A';
            document.getElementById('metric-ema20').textContent = market_conditions.ema_20 ? market_conditions.ema_20.toFixed(2) : 'N/A';
            document.getElementById('metric-ema50').textContent = market_conditions.ema_50 ? market_conditions.ema_50.toFixed(2) : 'N/A';
            document.getElementById('metric-macd').textContent = market_conditions.macd ? market_conditions.macd.toFixed(2) : 'N/A';
            document.getElementById('metric-stochk').textContent = market_conditions.stoch_k ? market_conditions.stoch_k.toFixed(2) : 'N/A';
            document.getElementById('metric-stochd').textContent = market_conditions.stoch_d ? market_conditions.stoch_d.toFixed(2) : 'N/A';
            
            const bbUpper = market_conditions.bb_upper ? market_conditions.bb_upper.toFixed(2) : 'N/A';
            const bbMid = market_conditions.bb_mid ? market_conditions.bb_mid.toFixed(2) : 'N/A';
            const bbLower = market_conditions.bb_lower ? market_conditions.bb_lower.toFixed(2) : 'N/A';
            document.getElementById('metric-bb').textContent = `${bbUpper} / ${bbMid} / ${bbLower}`;
            document.getElementById('metric-bb-width').textContent = market_conditions.bb_width ? market_conditions.bb_width.toFixed(2) : 'N/A';


            document.getElementById('market-trend').textContent = market_conditions.bullish_trend ? '📈 Uptrend' : '📉 Downtrend';
            let rsiZone = '';
            if (market_conditions.overbought) rsiZone = '🔥 Overbought';
            else if (market_conditions.oversold) rsiZone = '🧊 Oversold';
            else rsiZone = '✅ Neutral';
            document.getElementById('market-rsi-zone').textContent = rsiZone;

            let stochZone = '';
            if (market_conditions.stoch_overbought) stochZone = '🔥 Overbought';
            else if (market_conditions.stoch_oversold) stochZone = '🧊 Oversold';
            else stochZone = '✅ Neutral';
            document.getElementById('market-stoch-zone').textContent = stochZone;

            // Update Chart
            drawChart(chart_data);

            // Update Prediction Summary and Confidence Advisor if predictionResult is available
            if (predictionResult) {
                document.getElementById('summary-current-price').textContent = `$${predictionResult.current_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-avg-delta').textContent = `$${predictionResult.avg_delta_per_hour.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-time-left').textContent = `${predictionResult.hours_remaining} hr(s)`;
                document.getElementById('summary-projected-price').textContent = `$${predictionResult.projected_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-sentiment-score').textContent = predictionResult.sentiment.toFixed(2);
                document.getElementById('summary-target-time').textContent = predictionResult.target_time;

                const voteMessageDiv = document.getElementById('recommended-vote-message');
                voteMessageDiv.innerHTML = `<div class="success-message">🧠 Recommended Vote: <strong>${predictionResult.vote}</strong></div>`;
                voteMessageDiv.classList.remove('hidden');

                const confidence = predictionResult.confidence_advisor;
                
                // Update Trust Signals
                document.getElementById('trust-time').innerHTML = confidence.trust_conditions.time_expiry_lt_2hr ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-trend-text').textContent = selectedCurrency;
                document.getElementById('trust-trend').innerHTML = confidence.trust_conditions.trending_cleanly ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO (Trend unclear/Choppy)</strong>';
                document.getElementById('trust-sentiment').innerHTML = confidence.trust_conditions.sentiment_strong ? `<strong class="text-green-400">YES</strong> (Score: ${sentiment_score.toFixed(2)})` : `<strong class="text-red-400">NO</strong> (Score: ${sentiment_score.toFixed(2)})`;
                document.getElementById('trust-rsi').innerHTML = confidence.trust_conditions.rsi_neutral ? `<strong class="text-green-400">YES</strong> (RSI: ${market_conditions.rsi.toFixed(2)})` : `<strong class="text-red-400">NO</strong> (RSI: ${market_conditions.rsi.toFixed(2)})`;
                document.getElementById('trust-news').innerHTML = confidence.trust_conditions.no_major_news_expected_no_volume_spike ? '<strong class="text-green-400">YES</strong> (Sentiment not conflicting / No volume spike)' : '<strong class="text-red-400">NO</strong> (Sentiment conflicting / Volume spike)';
                document.getElementById('trust-stable-candles').innerHTML = confidence.trust_conditions.candle_bodies_stable_not_volatile ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-macd-bullish').innerHTML = confidence.trust_conditions.macd_bullish_crossover_confirmed ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-stoch-oversold').innerHTML = confidence.trust_conditions.stoch_oversold_bullish_cross ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-bb-lower').innerHTML = confidence.trust_conditions.price_near_bb_lower_stable_bands ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-no-massive-move').innerHTML = confidence.trust_conditions.no_massive_move_recent ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-bb-stable').innerHTML = confidence.trust_conditions.bb_stable ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';
                document.getElementById('trust-no-volume-spike').innerHTML = confidence.trust_conditions.no_volume_spike_recent ? '<strong class="text-green-400">YES</strong>' : '<strong class="text-red-400">NO</strong>';

                // Update Caution Flags
                document.getElementById('caution-time').innerHTML = confidence.caution_conditions.target_time_gt_3hr ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-massive-move-text').textContent = selectedCurrency;
                document.getElementById('caution-massive-move').innerHTML = confidence.caution_conditions.btc_massive_move ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-rsi').innerHTML = confidence.caution_conditions.rsi_extreme ? `<strong class="text-red-400">YES</strong> (RSI: ${market_conditions.rsi.toFixed(2)})` : `<strong class="text-green-400">NO</strong> (RSI: ${market_conditions.rsi.toFixed(2)})`;
                document.getElementById('caution-sentiment').innerHTML = confidence.caution_conditions.sentiment_conflicting ? `<strong class="text-red-400">YES</strong> (Score: ${sentiment_score.toFixed(2)})` : `<strong class="text-green-400">NO</strong> (Score: ${sentiment_score.toFixed(2)})`;
                document.getElementById('caution-big-news').innerHTML = confidence.caution_conditions.big_news_coming_or_volume_spike ? '<strong class="text-red-400">YES</strong> (Sentiment conflicting / Volume spike)' : '<strong class="text-green-400">NO</strong> (Sentiment not conflicting / No volume spike)';
                document.getElementById('caution-volatile-candles').innerHTML = confidence.caution_conditions.candle_volatility_high ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-macd-bearish').innerHTML = confidence.caution_conditions.macd_bearish_crossover_confirmed ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-stoch-overbought').innerHTML = confidence.caution_conditions.stoch_overbought_bearish_cross ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-bb-upper-contracting').innerHTML = confidence.caution_conditions.price_near_bb_upper_or_bb_volatile ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-bb-volatile').innerHTML = confidence.caution_conditions.bb_volatile ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';
                document.getElementById('caution-volume-spike').innerHTML = confidence.caution_conditions.volume_spike_recent ? '<strong class="text-red-400">YES</strong>' : '<strong class="text-green-400">NO</strong>';


                document.getElementById('total-trust-signals').textContent = confidence.trust_signals_count;
                document.getElementById('total-caution-flags').textContent = confidence.caution_flags_count;

                const proTipMessageDiv = document.getElementById('pro-tip-message');
                let proTipClass = '';
                let adviceMessage = confidence.advice_message;

                if (confidence.trust_signals_count >= 7 && confidence.caution_flags_count < 4) {
                    proTipClass = 'success-message';
                } else if (confidence.caution_flags_count >= 4) {
                    proTipClass = 'warning-message';
                } else {
                    proTipClass = 'info-message';
                }
                proTipMessageDiv.innerHTML = `<div class="${proTipClass}"><strong>${adviceMessage}</strong></div>`;
            } else {
                // Clear prediction results if no prediction is made
                document.getElementById('recommended-vote-message').classList.add('hidden');
                document.getElementById('pro-tip-message').innerHTML = '';
            }
        }

        // --- Charting with Plotly.js ---

        function drawChart(chartData) {
            if (!Array.isArray(chartData) || chartData.length === 0) {
                console.warn("No chart data available to draw.");
                Plotly.purge('candlestick-chart');
                return;
            }

            const timestamps = chartData.map(d => d.timestamp);
            const openPrices = chartData.map(d => d.open);
            const highPrices = chartData.map(d => d.high);
            const lowPrices = chartData.map(d => d.low);
            const closePrices = chartData.map(d => d.close);
            const volume = chartData.map(d => d.volume);
            const ema20 = chartData.map(d => d.EMA_20);
            const ema50 = chartData.map(d => d.EMA_50);
            const bbUpper = chartData.map(d => d.BB_Upper);
            const bbLower = chartData.map(d => d.BB_Lower);
            const bbMid = chartData.map(d => d.BB_Mid);
            const macd = chartData.map(d => d.MACD);
            const macdSignal = chartData.map(d => d.MACD_Signal);
            const macdHist = chartData.map(d => d.MACD_Hist);
            const stochK = chartData.map(d => d.STOCH_K);
            const stochD = chartData.map(d => d.STOCH_D);

            // Define traces
            const traces = [];

            // Candlestick trace (main price chart)
            traces.push({
                x: timestamps,
                open: openPrices,
                high: highPrices,
                low: lowPrices,
                close: closePrices,
                type: 'candlestick',
                name: 'Candles',
                increasing: { line: { color: '#FFD700' } }, /* Gold for increasing */
                decreasing: { line: { color: '#B22222' } }, /* Firebrick for decreasing */
                xaxis: 'x',
                yaxis: 'y'
            });

            // EMA 20
            traces.push({
                x: timestamps,
                y: ema20,
                type: 'scatter',
                mode: 'lines',
                name: 'EMA 20',
                line: { color: '#87CEEB', width: 1.5 }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // EMA 50
            traces.push({
                x: timestamps,
                y: ema50,
                type: 'scatter',
                mode: 'lines',
                name: 'EMA 50',
                line: { color: '#DAA520', width: 1.5 }, /* Goldenrod */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // BB Mid
            traces.push({
                x: timestamps,
                y: bbMid,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Mid',
                line: { color: '#A9A9A9', width: 1, dash: 'dash' }, /* DarkGrey */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });
            // BB Upper
            traces.push({
                x: timestamps,
                y: bbUpper,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Upper',
                line: { color: '#6A5ACD', width: 1 }, /* SlateBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });
            // BB Lower
            traces.push({
                x: timestamps,
                y: bbLower,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Lower',
                line: { color: '#6A5ACD', width: 1 }, /* SlateBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // Volume
            traces.push({
                x: timestamps,
                y: volume,
                type: 'bar',
                name: 'Volume',
                marker: { color: '#444444' }, /* Darker grey for volume bars */
                showlegend: false,
                xaxis: 'x2',
                yaxis: 'y2'
            });

            // MACD Line
            traces.push({
                x: timestamps,
                y: macd,
                type: 'scatter',
                mode: 'lines',
                name: 'MACD',
                line: { color: '#FFD700', width: 1.5 }, /* Gold */
                showlegend: true,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // MACD Signal Line
            traces.push({
                x: timestamps,
                y: macdSignal,
                type: 'scatter',
                mode: 'lines',
                name: 'Signal',
                line: { color: '#87CEEB', width: 1.5, dash: 'dot' }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // MACD Histogram
            traces.push({
                x: timestamps,
                y: macdHist,
                type: 'bar',
                name: 'Histogram',
                marker: {
                    color: macdHist.map(val => val >= 0 ? '#9ae6b4' : '#feb2b2') /* Green for positive, Red for negative */
                },
                showlegend: false,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // Stochastic %K
            traces.push({
                x: timestamps,
                y: stochK,
                type: 'scatter',
                mode: 'lines',
                name: '%K',
                line: { color: '#FFD700', width: 1.5 }, /* Gold */
                showlegend: true,
                xaxis: 'x4',
                yaxis: 'y4'
            });

            // Stochastic %D
            traces.push({
                x: timestamps,
                y: stochD,
                type: 'scatter',
                mode: 'lines',
                name: '%D',
                line: { color: '#87CEEB', width: 1.5, dash: 'dot' }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x4',
                yaxis: 'y4'
            });

            // Define layout with multiple axes
            const layout = {
                grid: {
                    rows: 4,
                    columns: 1,
                    pattern: 'independent',
                    rowheights: [0.5, 0.2, 0.15, 0.15],
                    subplots: [['xy'], ['xy2'], ['xy3'], ['xy4']] // Map traces to subplots
                },
                xaxis: {
                    rangeslider: { visible: false },
                    type: 'date',
                    title: 'Time',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis2: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis3: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis4: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis: {
                    title: 'Price (USDT)',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis2: {
                    title: 'Volume',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis3: {
                    title: 'MACD',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis4: {
                    title: 'Stochastic',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444',
                    range: [0, 100] /* Stochastic is always 0-100 */
                },
                plot_bgcolor: '#222222',
                paper_bgcolor: '#222222',
                font: { color: '#FFD700' },
                margin: { l: 40, r: 40, t: 30, b: 30 },
                showlegend: true,
                legend: {
                    x: 0, y: 1.15,
                    bgcolor: 'rgba(0,0,0,0)',
                    bordercolor: 'rgba(0,0,0,0)',
                    font: { color: '#FFD700' }
                }
            };

            Plotly.newPlot('candlestick-chart', traces, layout, { responsive: true, displayModeBar: true });
        }

        // --- Main Application Logic ---

        function showLoading(elementId) {
            document.getElementById(elementId).classList.remove('hidden');
        }

        function hideLoading(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function updateCurrentISTTime() {
            const now = new Date();
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'Asia/Kolkata'
            };
            document.getElementById('current-ist-time').textContent = now.toLocaleTimeString('en-IN', options);
        }

        async function initializeApp() {
            showLoading('loading-spinner');
            document.getElementById('current-price-display').textContent = "Loading...";
            const messageDiv = document.getElementById('recommended-vote-message');
            messageDiv.innerHTML = '';
            messageDiv.classList.add('hidden');
            document.getElementById('pro-tip-message').innerHTML = '';

            try {
                const response = await fetch(`${BACKEND_API_URL}/api/market_data`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`HTTP error! status: ${response.status} - ${errorData.error || response.statusText}`);
                }
                allMarketData = await response.json();
                
                // Update UI with data for the currently selected currency
                updateUI(allMarketData[selectedCurrency]);

            } catch (error) {
                console.error("Error fetching market data:", error);
                const messageDiv = document.getElementById('recommended-vote-message');
                messageDiv.innerHTML = `<div class="error-message">❌ Failed to load market data. Please ensure the backend server is running and accessible at ${BACKEND_API_URL}. Error: ${error.message}</div>`;
                messageDiv.classList.remove('hidden');
                document.getElementById('current-price-display').textContent = "$ERROR";
            } finally {
                hideLoading('loading-spinner');
            }
        }

        // Handle form submission
        document.getElementById('prediction-form').addEventListener('submit', async (event) => {
            event.preventDefault();

            showLoading('prediction-spinner');
            const targetPrice = parseFloat(document.getElementById('target-price').value);
            const targetTimeStr = document.getElementById('target-time').value;
            const selectedCurrencyForPrediction = document.querySelector('input[name="currency"]:checked').value;

            const messageDiv = document.getElementById('recommended-vote-message');
            messageDiv.innerHTML = '';
            messageDiv.classList.add('hidden');
            document.getElementById('pro-tip-message').innerHTML = '';

            if (isNaN(targetPrice) || !targetTimeStr) {
                messageDiv.innerHTML = `<div class="error-message">❌ Please enter a valid target price and time.</div>`;
                messageDiv.classList.remove('hidden');
                hideLoading('prediction-spinner');
                return;
            }

            try {
                const response = await fetch(`${BACKEND_API_URL}/api/predict`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        target_price: targetPrice,
                        target_time: targetTimeStr,
                        currency: selectedCurrencyForPrediction
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Prediction failed: ${errorData.error || response.statusText}`);
                }

                const predictionResult = await response.json();
                
                // Re-fetch all market data to ensure the UI is consistent with the latest backend state
                const marketDataResponse = await fetch(`${BACKEND_API_URL}/api/market_data`);
                if (!marketDataResponse.ok) {
                    const errorData = await marketDataResponse.json();
                    throw new Error(`Failed to refresh market data after prediction: ${errorData.error || marketDataResponse.statusText}`);
                }
                allMarketData = await marketDataResponse.json();
                
                // Update UI with the prediction result for the *selected* currency
                updateUI(allMarketData[selectedCurrency], predictionResult);

            } catch (error) {
                console.error("Error during prediction:", error);
                messageDiv.innerHTML = `<div class="error-message">❌ ${error.message}</div>`;
                messageDiv.classList.remove('hidden');
            } finally {
                hideLoading('prediction-spinner');
            }
        });

        // Handle currency selection change
        document.querySelectorAll('input[name="currency"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                selectedCurrency = event.target.value;
                // Update UI immediately with the newly selected currency's data
                updateUI(allMarketData[selectedCurrency]);
            });
        });

        // Initialize the app when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            updateCurrentISTTime(); // Set initial time
            setInterval(updateCurrentISTTime, 1000); // Update time every second
        });

        // Periodically update market data (e.g., every 1 minute for a more "real-time" feel)
        setInterval(initializeApp, 60000); // 60000 ms = 1 minute

    </script>
</body>
</html>


--- END FILE: index.html ---

--- START FILE: predictor.py ---

# predictor.py

import datetime
import pandas as pd # Ensure pandas is imported

# Removed redundant imports (fetch_ohlcv, add_technical_indicators, get_current_price, get_bitcoin_sentiment)
# as these functions will now receive the necessary data (df, current_price, sentiment_score)
# directly from the calling backend_app.py

def predict_future_price(df: pd.DataFrame, current_price: float, hours_ahead: float = 1):
    """
    Predicts the future price based on historical price changes.

    Args:
        df (pd.DataFrame): DataFrame containing historical OHLCV data, specifically 'close' prices.
        current_price (float): The current BTC price.
        hours_ahead (float): The number of hours into the future to predict.

    Returns:
        tuple: (projected_price, average_delta_per_hour, current_price)
    """
    if df.empty or 'close' not in df.columns or len(df) < 2:
        # Not enough data to calculate price changes, return current price as projected
        print("Warning: Not enough data in DataFrame for accurate price prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Ensure 'close' column is numeric
    df_numeric_close = pd.to_numeric(df['close'], errors='coerce').dropna()
    if df_numeric_close.empty or len(df_numeric_close) < 2:
        print("Warning: 'close' column has insufficient numeric data for prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Calculate average price movement per hour from the historical data
    price_changes = df_numeric_close.diff().dropna()
    
    avg_delta = price_changes.mean() if not price_changes.empty else 0.0

    projected_price = current_price + (avg_delta * hours_ahead)

    return round(projected_price, 2), round(avg_delta, 2), current_price

def recommend_probo_vote_for_target(df: pd.DataFrame, current_price: float, sentiment_score: float, target_price: float, target_time_str: str):
    """
    Recommends a 'YES' or 'NO' vote for a Probo outcome based on projected price and sentiment.

    Args:
        df (pd.DataFrame): DataFrame containing historical OHLCV data.
        current_price (float): The current BTC price.
        sentiment_score (float): The current Bitcoin sentiment score.
        target_price (float): The target price for the Probo outcome.
        target_time_str (str): The target time in "HH:MM" format (UTC).

    Returns:
        dict: A dictionary containing prediction details and the recommended vote.
    """
    # 1. Parse time and calculate hours remaining
    now_utc = datetime.datetime.utcnow()
    
    # Parse target_time_str (which is expected to be HH:MM in UTC from backend)
    target_time_only = datetime.datetime.strptime(target_time_str, "%H:%M").time()
    
    # Combine today's UTC date with target time
    target_datetime_utc = now_utc.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)
    
    # If target time has already passed today (UTC), assume it's for tomorrow
    if target_datetime_utc < now_utc:
        target_datetime_utc += datetime.timedelta(days=1)

    hours_remaining = (target_datetime_utc - now_utc).total_seconds() / 3600
    hours_remaining = max(0.25, round(hours_remaining, 2))  # Minimum 15 min window (0.25 hours)

    # 2. Use passed sentiment
    sentiment = sentiment_score

    # 3. Predict price using the provided df and current_price
    projected, delta, current = predict_future_price(df, current_price, hours_remaining)

    # 4. Decision logic
    # Vote 'YES' if projected price meets or exceeds target AND sentiment is not strongly negative
    if projected >= target_price and sentiment >= -0.1:
        vote = "YES"
    else:
        vote = "NO"

    # 5. Return analysis
    result = {
        "current_price": current,
        "avg_delta_per_hour": delta,
        "hours_remaining": hours_remaining,
        "projected_price": projected,
        "sentiment": sentiment,
        "target_price": target_price,
        "target_time": target_time_str, # Keep the original HH:MM string for display
        "vote": vote
    }

    return result

if __name__ == "__main__":
    # This block is for local testing of predictor.py's functions
    # In a real application, these functions are called by backend_app.py
    print("--- Testing predictor.py (requires mock data) ---")
    
    # Example of how to test locally (uncomment and run if needed)
    # from btc_data import fetch_ohlcv, add_technical_indicators, get_current_price
    # from sentiment import get_bitcoin_sentiment

    # print("Fetching mock data for local predictor test...")
    # df_test = fetch_ohlcv(limit=50) # Fetch some data
    # df_test = add_technical_indicators(df_test) # Add indicators
    # current_price_test = get_current_price() # Get current price
    # sentiment_test = get_bitcoin_sentiment() # Get sentiment

    # if not df_test.empty and current_price_test > 0:
    #     target_price_test = current_price_test + 500 # Example target
    #     target_time_test = (datetime.datetime.utcnow() + datetime.timedelta(hours=2)).strftime("%H:%M") # 2 hours from now UTC

    #     question = recommend_probo_vote_for_target(
    #         df=df_test,
    #         current_price=current_price_test,
    #         sentiment_score=sentiment_test,
    #         target_price=target_price_test,
    #         target_time_str=target_time_test
    #     )
        
    #     print("\n🧠 Prediction Summary (Local Test):")
    #     for k, v in question.items():
    #         print(f"{k.replace('_', ' ').title()}: {v}")
    # else:
    #     print("Could not fetch sufficient data for local predictor test.")



--- END FILE: predictor.py ---

--- START FILE: probo_strategy.py ---

# probo_strategy.py

import pandas as pd
import numpy as np # Import numpy to check for NaN

def interpret_market_conditions(df: pd.DataFrame):
    """
    Interprets market conditions based on technical indicators (RSI, EMA)
    and new volatility/price movement metrics.

    Args:
        df (pandas.DataFrame): DataFrame with 'RSI', 'EMA_20', 'EMA_50',
                               'body_size', 'candle_range', 'wick_to_body_ratio' columns.

    Returns:
        dict: A dictionary containing interpreted market conditions.
    """
    required_cols = ['RSI', 'EMA_20', 'EMA_50', 'body_size', 'candle_range', 'wick_to_body_ratio', 'close']
    if df.empty or not all(col in df.columns for col in required_cols):
        print("Warning: DataFrame is empty or missing required columns for market interpretation. Returning default conditions.")
        return {
            "bullish_trend": False,
            "oversold": False,
            "overbought": False,
            "rsi": 50.0,
            "ema_20": 0.0,
            "ema_50": 0.0,
            "massive_move_recent": False, # New default
            "candle_volatility_high": False, # New default
            "candle_bodies_stable": False # New default
        }

    # Get the latest values
    latest = df.iloc[-1]

    # Convert numpy types to standard Python types and handle NaN
    rsi = float(latest["RSI"]) if pd.notna(latest["RSI"]) else None
    ema_20 = float(latest["EMA_20"]) if pd.notna(latest["EMA_20"]) else None
    ema_50 = float(latest["EMA_50"]) if pd.notna(latest["EMA_50"]) else None
    
    # New metrics
    latest_close = float(latest["close"]) if pd.notna(latest["close"]) else None
    latest_body_size = float(latest["body_size"]) if pd.notna(latest["body_size"]) else None
    latest_candle_range = float(latest["candle_range"]) if pd.notna(latest["candle_range"]) else None
    latest_wick_to_body_ratio = float(latest["wick_to_body_ratio"]) if pd.notna(latest["wick_to_body_ratio"]) else None

    # Trend signal: EMA20 > EMA50 generally indicates an uptrend
    bullish_trend = bool(ema_20 is not None and ema_50 is not None and ema_20 > ema_50)
    
    # RSI zones
    oversold = bool(rsi is not None and rsi < 30)
    overbought = bool(rsi is not None and rsi > 70)

    # --- Automated Analysis for previously manual checks ---

    # 1. "BTC just made a massive move"
    # Check for a significant percentage change over the last few candles (e.g., last 4 hours)
    massive_move_recent = False
    if len(df) >= 4 and latest_close is not None:
        # Calculate percentage change over the last 4 hours (or fewer if less data)
        past_close = df['close'].iloc[-4] if len(df) >= 4 else df['close'].iloc[0]
        if pd.notna(past_close) and past_close != 0:
            percent_change = abs((latest_close - past_close) / past_close) * 100
            # Define "massive" as, for example, > 2% move in 4 hours
            if percent_change > 2.0: # Threshold for a "massive move"
                massive_move_recent = True

    # 2. "Candle volatility is high (huge wicks)" / "Candle bodies are stable (not huge wicks)"
    candle_volatility_high = False
    candle_bodies_stable = False

    if latest_wick_to_body_ratio is not None and latest_body_size is not None and latest_candle_range is not None:
        # High volatility: high wick-to-body ratio OR large total candle range relative to price
        # Thresholds are examples and might need tuning
        if latest_wick_to_body_ratio > 1.5 or (latest_candle_range / latest_close) * 100 > 1.0: # Example: wicks 1.5x body, or 1% range
            candle_volatility_high = True
        
        # Stable bodies: small wick-to-body ratio AND decent body size (not a doji)
        # Assuming 'stable' means not too small (doji) and not dominated by wicks
        if latest_wick_to_body_ratio < 0.5 and (latest_body_size / latest_close) * 100 > 0.1: # Example: wicks < 0.5x body, body > 0.1% of price
            candle_bodies_stable = True
    
    # If volatility is high, then bodies are NOT stable. These are often mutually exclusive.
    # Prioritize volatility if detected.
    if candle_volatility_high:
        candle_bodies_stable = False # If high volatility, bodies are not stable

    return {
        "bullish_trend": bullish_trend,
        "oversold": oversold,
        "overbought": overbought,
        "rsi": rsi,
        "ema_20": ema_20,
        "ema_50": ema_50,
        "massive_move_recent": massive_move_recent,
        "candle_volatility_high": candle_volatility_high,
        "candle_bodies_stable": candle_bodies_stable
    }

# The recommend_probo_vote function below is likely for standalone testing
# or was part of a previous Streamlit app. It is not directly called by the Flask backend
# in the current design, as the prediction logic is handled by backend_app.py calling predictor.py.
def recommend_probo_vote():
    """
    (Deprecated for Flask backend usage)
    Recommends a Probo vote based on market conditions and sentiment.
    This function is more suitable for a standalone script or a Streamlit app.
    For the Flask backend, individual components (fetch_ohlcv, add_technical_indicators,
    get_current_price, get_bitcoin_sentiment, interpret_market_conditions) are called
    and their results are used to build the prediction.
    """
    from btc_data import fetch_ohlcv, add_technical_indicators, get_current_price
    from sentiment import get_bitcoin_sentiment

    print("[+] Fetching market data...")
    df = fetch_ohlcv()
    if df.empty:
        print("Failed to fetch OHLCV data. Cannot recommend vote.")
        return "N/A"

    df = add_technical_indicators(df)
    market = interpret_market_conditions(df)
    price = get_current_price()

    print("[+] Analyzing sentiment...")
    sentiment_score = get_bitcoin_sentiment()

    print("\n📊 BTC Market Snapshot")
    print(f"Price: ${price:.2f}")
    # Handle None values for display
    rsi_display = f"{market['rsi']:.2f}" if market['rsi'] is not None else "N/A"
    ema20_display = f"{market['ema_20']:.2f}" if market['ema_20'] is not None else "N/A"
    ema50_display = f"{market['ema_50']:.2f}" if market['ema_50'] is not None else "N/A"
    print(f"RSI: {rsi_display} | EMA20: {ema20_display} | EMA50: {ema50_display}")
    sentiment_status = 'Bullish' if sentiment_score > 0 else 'Bearish' if sentiment_score < 0 else 'Neutral'
    print(f"Sentiment Score: {sentiment_score:.3f} ({sentiment_status})")

    # Decision logic (simplified for this example)
    vote = "NO"
    if market["bullish_trend"] and sentiment_score > 0.1:
        vote = "YES"
    elif market["oversold"] and sentiment_score > -0.05:
        vote = "YES"
    elif market["overbought"] and sentiment_score < -0.1:
        vote = "NO"

    print(f"\n🧠 Probo Recommendation: ✅ Vote {vote}")
    return vote

if __name__ == "__main__":
    print("--- Running standalone Probo Strategy Recommendation ---")
    recommend_probo_vote()


--- END FILE: probo_strategy.py ---

--- START FILE: README.md ---

Website Link : https://probo-crypto-predictor.netlify.app/


--- END FILE: README.md ---

--- START FILE: requirements.txt ---

streamlit
pandas
requests
plotly
ta
feedparser
textblob
urllib3
python-telegram-bot==13.15
flask
flask-cors
gunicorn
pytz
numpy
scikit-learn # NEWLY ADDED
prophet

--- END FILE: requirements.txt ---

--- START FILE: sentiment.py ---

# sentiment.py

import feedparser
from textblob import TextBlob
import urllib.parse
# Removed: import streamlit as st

def fetch_news_sentiment(query="bitcoin", max_items=20):
    """
    Fetches news headlines for a given query from Google News RSS and calculates
    an average sentiment polarity using TextBlob.

    Args:
        query (str): The search query (e.g., "bitcoin").
        max_items (int): Maximum number of news items to process.

    Returns:
        float: Average sentiment polarity (between -1.0 and 1.0).
               Returns 0.0 if no headlines are found or an error occurs.
    """
    encoded_query = urllib.parse.quote(query)  # URL encode the query
    url = f"https://news.google.com/rss/search?q={encoded_query}"
    
    try:
        feed = feedparser.parse(url)
        headlines = [entry.title for entry in feed.entries[:max_items]]

        if not headlines:
            print(f"No news headlines found for query: '{query}'")
            return 0.0  # Neutral if no news

        sentiments = [TextBlob(headline).sentiment.polarity for headline in headlines]
        return round(sum(sentiments) / len(sentiments), 3)
    except Exception as e:
        print(f"Error fetching or analyzing news sentiment for '{query}': {e}")
        return 0.0 # Return neutral sentiment on error

# Removed: @st.cache_data(ttl=600) decorator as it's Streamlit-specific
def get_bitcoin_sentiment():
    """
    Gets the sentiment score specifically for Bitcoin.
    """
    return fetch_news_sentiment("bitcoin OR btc")

if __name__ == "__main__":
    print("--- Testing sentiment.py ---")
    sentiment = get_bitcoin_sentiment()
    print(f"Bitcoin Sentiment Score: {sentiment}")
    if sentiment > 0:
        print("Market sentiment is positive.")
    elif sentiment < 0:
        print("Market sentiment is negative.")
    else:
        print("Market sentiment is neutral or could not be determined.")



--- END FILE: sentiment.py ---

--- START FILE: site.webmanifest ---

{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}

--- END FILE: site.webmanifest ---

--- START FILE: telegram_bot.py ---

# telegram_bot.py
import requests
import os

# Your bot token and user ID
# Get BOT_TOKEN from environment variable
# IMPORTANT: Replace "YOUR_FALLBACK_TOKEN_IF_NOT_SET" with a dummy value
# but ensure you set the actual environment variable in your deployment environment.
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "YOUR_FALLBACK_TOKEN_IF_NOT_SET")
USER_ID = os.environ.get("TELEGRAM_USER_ID", 5368095453) # Or keep your numeric ID if it's constant

def send_telegram_alert(message):
    """
    Sends a Markdown-formatted message as an alert to a specified Telegram user.

    Args:
        message (str): The message content to send.
    """
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_FALLBACK_TOKEN_IF_NOT_SET":
        print("❌ Telegram BOT_TOKEN not configured. Alert not sent. Please set the TELEGRAM_BOT_TOKEN environment variable.")
        return
    
    if not USER_ID:
        print("❌ Telegram USER_ID not configured. Alert not sent. Please set the TELEGRAM_USER_ID environment variable.")
        return

    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": USER_ID,
        "text": message,
        "parse_mode": "Markdown" # Allows bold, italics, etc.
    }
    try:
        response = requests.post(url, json=payload, timeout=10) # Add timeout
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        if response.status_code == 200:
            print("✅ Telegram alert sent successfully.")
        else:
            print(f"❌ Failed to send alert (status code: {response.status_code}): {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"❌ Telegram alert error (network/request issue): {str(e)}")
    except Exception as e:
        print(f"❌ An unexpected error occurred while sending Telegram alert: {str(e)}")

# Test message
if __name__ == "__main__":
    print("--- Testing telegram_bot.py ---")
    # For local testing, you MUST set the environment variables in your terminal
    # before running this script. Example:
    # export TELEGRAM_BOT_TOKEN="YOUR_ACTUAL_BOT_TOKEN_HERE"
    # export TELEGRAM_USER_ID="YOUR_ACTUAL_USER_ID_HERE"
    
    test_message = "🚨 *Test Alert* from BTC Probo Predictor! If you see this, the bot is working."
    send_telegram_alert(test_message)



--- END FILE: telegram_bot.py ---
