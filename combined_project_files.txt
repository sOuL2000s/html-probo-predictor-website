
--- START FILE: .gitignore ---

# Python
*.pyc
__pycache__/
venv/
.env

# MacOS
.DS_Store

# IDEs (add as needed)
.vscode/
.idea/

# Plotly temp files
plotly_images/

--- END FILE: .gitignore ---

--- START FILE: backend_app.py ---

from flask import Flask, jsonify, request
from flask_cors import CORS
import os
from datetime import datetime, timedelta
import pandas as pd
import pytz
import numpy as np
import requests
import feedparser
from textblob import TextBlob
import urllib.parse
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.trend import EMAIndicator, MACD
from ta.volatility import BollingerBands
from prophet import Prophet

# --- Gemini API Integration ---
import google.generativeai as genai
from PIL import Image # For image handling
import io # For file processing

app = Flask(__name__)
CORS(app)

# --- Global Data Storage ---
# Data for Bitcoin
btc_market_data_df = None
btc_current_price = 0.0
btc_sentiment_score = 0.0
btc_market_conditions = {}

# Data for Ethereum
eth_market_data_df = None
eth_current_price = 0.0
eth_sentiment_score = 0.0
eth_market_conditions = {}

# --- Configuration ---
BINANCE_BASE_URL = "https://api.binance.com"
# Telegram Bot Token and User ID are removed as per request.

# Gemini Configuration
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA") # Your provided key
genai.configure(api_key=GEMINI_API_KEY)
# Using gemini-1.5-flash-latest for stability, but user requested "gemini-2.5-flash-preview-05-20"
# Trying with the user's specified model, if it fails, a more stable one might be needed.
GEMINI_PREDICTION_MODEL_NAME = "gemini-2.5-flash-preview-05-20"
GEMINI_CHAT_MODEL_NAME = "gemini-2.5-flash-preview-05-20" # Chat is good with latest flash

# Ensure models are initialized
try:
    gemini_prediction_model = genai.GenerativeModel(GEMINI_PREDICTION_MODEL_NAME)
    gemini_chat_model = genai.GenerativeModel(GEMINI_CHAT_MODEL_NAME)
    print(f"Gemini Prediction Model '{GEMINI_PREDICTION_MODEL_NAME}' initialized.")
    print(f"Gemini Chat Model '{GEMINI_CHAT_MODEL_NAME}' initialized.")
except Exception as e:
    print(f"Error initializing Gemini models: {e}")
    print("Please check your API key and model names. Proceeding without Gemini functionality.")
    gemini_prediction_model = None
    gemini_chat_model = None

# --- Crypto Data Functions ---

def fetch_ohlcv(symbol="BTCUSDT", interval="1h", limit=200): # Increased limit for better indicator calculation
    """
    Fetches OHLCV (Open, High, Low, Close, Volume) data from Binance for a given symbol.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    
    try:
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        if not data:
            print(f"No data received for {symbol} with interval {interval}.")
            return pd.DataFrame()

        df = pd.DataFrame(data, columns=[
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_buy_base_vol", "taker_buy_quote_vol", "ignore"
        ])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.set_index("timestamp", inplace=True)
        
        for col in ["open", "high", "low", "close", "volume"]:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        
        df.dropna(subset=["open", "high", "low", "close", "volume"], inplace=True)

        return df[["open", "high", "low", "close", "volume"]]
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OHLCV data from Binance for {symbol}: {e}")
        return pd.DataFrame()
    except ValueError as e:
        print(f"Error parsing JSON data from Binance for {symbol}: {e}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in fetch_ohlcv for {symbol}: {e}")
        return pd.DataFrame()

def add_technical_indicators(df):
    """
    Adds RSI, EMA 20, EMA 50, MACD, Stochastic Oscillator, Bollinger Bands,
    and candle volatility metrics to the DataFrame.
    """
    if df.empty or not all(col in df.columns for col in ['open', 'high', 'low', 'close', 'volume']):
        print("DataFrame is empty or missing required OHLCV columns for indicator calculation.")
        return df

    for col in ['open', 'high', 'low', 'close', 'volume']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    df.dropna(subset=['open', 'high', 'low', 'close', 'volume'], inplace=True)

    if df.empty:
        return df

    # Calculate RSI
    if len(df) >= 14:
        rsi = RSIIndicator(df["close"], window=14).rsi()
        df["RSI"] = rsi
    else:
        df["RSI"] = float('nan')

    # Calculate EMA 20
    if len(df) >= 20:
        ema_20 = EMAIndicator(df["close"], window=20).ema_indicator()
        df["EMA_20"] = ema_20
    else:
        df["EMA_20"] = float('nan')

    # Calculate EMA 50
    if len(df) >= 50:
        ema_50 = EMAIndicator(df["close"], window=50).ema_indicator()
        df["EMA_50"] = ema_50
    else:
        df["EMA_50"] = float('nan')

    # Calculate MACD
    if len(df) >= 34: # MACD needs 12 (fast EMA) + 26 (slow EMA) periods to stabilize, 34 is safer.
        macd_indicator = MACD(df["close"])
        df["MACD"] = macd_indicator.macd()
        df["MACD_Signal"] = macd_indicator.macd_signal()
        df["MACD_Hist"] = macd_indicator.macd_diff()
    else:
        df["MACD"] = float('nan')
        df["MACD_Signal"] = float('nan')
        df["MACD_Hist"] = float('nan')

    # Calculate Stochastic Oscillator
    if len(df) >= 14: # Stochastic needs at least 14 periods
        stoch_indicator = StochasticOscillator(df["high"], df["low"], df["close"])
        df["STOCH_K"] = stoch_indicator.stoch()
        df["STOCH_D"] = stoch_indicator.stoch_signal()
    else:
        df["STOCH_K"] = float('nan')
        df["STOCH_D"] = float('nan')

    # Calculate Bollinger Bands
    if len(df) >= 20: # Bollinger Bands typically use 20 periods
        bb_indicator = BollingerBands(df["close"])
        df["BB_Upper"] = bb_indicator.bollinger_hband()
        df["BB_Lower"] = bb_indicator.bollinger_lband()
        df["BB_Mid"] = bb_indicator.bollinger_mavg()
        df["BB_Width"] = bb_indicator.bollinger_wband()
        df["BB_Percent"] = bb_indicator.bollinger_pband() # %B
    else:
        df["BB_Upper"] = float('nan')
        df["BB_Lower"] = float('nan')
        df["BB_Mid"] = float('nan')
        df["BB_Width"] = float('nan')
        df["BB_Percent"] = float('nan')

    # Candle Volatility Metrics
    df['body_size'] = abs(df['close'] - df['open'])
    df['candle_range'] = df['high'] - df['low']
    df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
    df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']
    df['total_wick_size'] = df['upper_wick'] + df['lower_wick']

    df['wick_to_body_ratio'] = df.apply(
        lambda row: row['total_wick_size'] / row['body_size'] if row['body_size'] > 0 else (1.0 if row['total_wick_size'] > 0 else 0.0),
        axis=1
    )
    return df

def get_current_price(symbol="BTCUSDT"):
    """
    Fetches the current price of a given symbol from Binance.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/ticker/price?symbol={symbol}"
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return float(response.json()["price"])
    except requests.exceptions.RequestException as e:
        print(f"Error fetching current price for {symbol} from Binance: {e}")
        return 0.0
    except (ValueError, KeyError) as e:
        print(f"Error parsing current price data for {symbol}: {e}")
        return 0.0
    except Exception as e:
        print(f"An unexpected error occurred in get_current_price for {symbol}: {e}")
        return 0.0

# --- Sentiment Functions (consolidated) ---

def fetch_news_sentiment(query="bitcoin", max_items=20):
    """
    Fetches news headlines for a given query from Google News RSS and calculates
    an average sentiment polarity using TextBlob.
    """
    encoded_query = urllib.parse.quote(query)
    url = f"https://news.google.com/rss/search?q={encoded_query}"
    
    try:
        feed = feedparser.parse(url)
        headlines = [entry.title for entry in feed.entries[:max_items]]

        if not headlines:
            print(f"No news headlines found for query: '{query}'")
            return 0.0

        sentiments = [TextBlob(headline).sentiment.polarity for headline in headlines]
        return round(sum(sentiments) / len(sentiments), 3)
    except Exception as e:
        print(f"Error fetching or analyzing news sentiment for '{query}': {e}")
        return 0.0

def get_crypto_sentiment(crypto_name="bitcoin"):
    """
    Gets the sentiment score for a specific cryptocurrency.
    """
    return fetch_news_sentiment(f"{crypto_name} OR {crypto_name[:3].upper()}")

# --- Market Interpretation (consolidated and enhanced) ---

def interpret_market_conditions(df: pd.DataFrame):
    """
    Interprets market conditions based on technical indicators and volatility metrics.
    Incorporates RSI, EMA, MACD, Stochastic, Bollinger Bands, and candle volatility.
    """
    required_cols = [
        'RSI', 'EMA_20', 'EMA_50', 'MACD', 'MACD_Signal', 'MACD_Hist',
        'STOCH_K', 'STOCH_D', 'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent',
        'body_size', 'candle_range', 'wick_to_body_ratio', 'close', 'volume'
    ]
    if df.empty or not all(col in df.columns for col in required_cols):
        print("Warning: DataFrame is empty or missing required columns for market interpretation. Returning default conditions.")
        # Initialize with None to correctly reflect missing data, rather than default values
        return {k: None for k in [
            "bullish_trend", "oversold", "overbought", "rsi", "ema_20", "ema_50",
            "macd", "macd_signal", "macd_hist", "stoch_k", "stoch_d",
            "bb_upper", "bb_lower", "bb_mid", "bb_width", "bb_percent",
            "massive_move_recent", "candle_volatility_high", "candle_bodies_stable",
            "macd_bullish_crossover", "macd_bearish_crossover",
            "stoch_oversold", "stoch_overbought",
            "price_near_bb_lower", "price_near_bb_upper",
            "bb_contracting", "bb_expanding", "volume_spike_recent"
        ]}

    latest = df.iloc[-1]

    # Extract values, handling potential NaN
    rsi = float(latest["RSI"]) if pd.notna(latest["RSI"]) else None
    ema_20 = float(latest["EMA_20"]) if pd.notna(latest["EMA_20"]) else None
    ema_50 = float(latest["EMA_50"]) if pd.notna(latest["EMA_50"]) else None
    macd = float(latest["MACD"]) if pd.notna(latest["MACD"]) else None
    macd_signal = float(latest["MACD_Signal"]) if pd.notna(latest["MACD_Signal"]) else None
    macd_hist = float(latest["MACD_Hist"]) if pd.notna(latest["MACD_Hist"]) else None
    stoch_k = float(latest["STOCH_K"]) if pd.notna(latest["STOCH_K"]) else None
    stoch_d = float(latest["STOCH_D"]) if pd.notna(latest["STOCH_D"]) else None
    bb_upper = float(latest["BB_Upper"]) if pd.notna(latest["BB_Upper"]) else None
    bb_lower = float(latest["BB_Lower"]) if pd.notna(latest["BB_Lower"]) else None
    bb_width = float(latest["BB_Width"]) if pd.notna(latest["BB_Width"]) else None
    bb_percent = float(latest["BB_Percent"]) if pd.notna(latest["BB_Percent"]) else None
    latest_close = float(latest["close"]) if pd.notna(latest["close"]) else None
    latest_body_size = float(latest["body_size"]) if pd.notna(latest["body_size"]) else None
    latest_candle_range = float(latest["candle_range"]) if pd.notna(latest["candle_range"]) else None
    latest_wick_to_body_ratio = float(latest["wick_to_body_ratio"]) if pd.notna(latest["wick_to_body_ratio"]) else None
    latest_volume = float(latest["volume"]) if pd.notna(latest["volume"]) else None

    # Trend and Momentum
    bullish_trend = bool(ema_20 is not None and ema_50 is not None and ema_20 > ema_50)
    rsi_oversold = bool(rsi is not None and rsi < 30)
    rsi_overbought = bool(rsi is not None and rsi > 70)
    
    macd_bullish_crossover = bool(macd is not None and macd_signal is not None and macd > macd_signal and macd_hist is not None and macd_hist > 0)
    macd_bearish_crossover = bool(macd is not None and macd_signal is not None and macd < macd_signal and macd_hist is not None and macd_hist < 0)

    stoch_oversold = bool(stoch_k is not None and stoch_d is not None and stoch_k < 20 and stoch_d < 20 and stoch_k > stoch_d) # Added K > D for potential rebound
    stoch_overbought = bool(stoch_k is not None and stoch_d is not None and stoch_k > 80 and stoch_d > 80 and stoch_k < stoch_d) # Added K < D for potential reversal

    # Volatility and Price Action
    massive_move_recent = False
    if len(df) >= 4 and latest_close is not None:
        past_close = df['close'].iloc[-4] if len(df) >= 4 else df['close'].iloc[0]
        if pd.notna(past_close) and past_close != 0:
            percent_change = abs((latest_close - past_close) / past_close) * 100
            if percent_change > 2.0: # Define "massive" as > 2% move in 4 hours
                massive_move_recent = True

    candle_volatility_high = False
    candle_bodies_stable = False
    if latest_wick_to_body_ratio is not None and latest_body_size is not None and latest_candle_range is not None and latest_close is not None:
        if latest_wick_to_body_ratio > 1.5 or (latest_candle_range / latest_close) * 100 > 1.0:
            candle_volatility_high = True
        if latest_wick_to_body_ratio < 0.5 and (latest_body_size / latest_close) * 100 > 0.1:
            candle_bodies_stable = True
    if candle_volatility_high: # If high volatility, bodies are NOT stable.
        candle_bodies_stable = False

    # Bollinger Band interpretations
    price_near_bb_lower = bool(latest_close is not None and bb_lower is not None and latest_close <= bb_lower * 1.005) # Within 0.5% of lower band
    price_near_bb_upper = bool(latest_close is not None and bb_upper is not None and latest_close >= bb_upper * 0.995) # Within 0.5% of upper band
    
    bb_contracting = False
    bb_expanding = False
    if len(df) >= 20 and bb_width is not None:
        rolling_bb_width_avg = df['BB_Width'].iloc[-20:].mean() # Average of last 20 widths
        if rolling_bb_width_avg is not None and rolling_bb_width_avg > 0:
            if bb_width < rolling_bb_width_avg * 0.9: # 10% narrower than recent average
                bb_contracting = True
            elif bb_width > rolling_bb_width_avg * 1.1: # 10% wider than recent average
                bb_expanding = True

    # Volume Analysis: Check for significant volume spikes
    volume_spike_recent = False
    if len(df) >= 10 and latest_volume is not None:
        avg_volume_past = df['volume'].iloc[-10:-1].mean() # Average of last 9 volumes
        if avg_volume_past is not None and avg_volume_past > 0:
            if latest_volume > avg_volume_past * 1.5: # Current volume is 50% higher than recent average
                volume_spike_recent = True

    return {
        "bullish_trend": bullish_trend,
        "oversold": rsi_oversold,
        "overbought": rsi_overbought,
        "rsi": rsi,
        "ema_20": ema_20,
        "ema_50": ema_50,
        "macd": macd,
        "macd_signal": macd_signal,
        "macd_hist": macd_hist,
        "stoch_k": stoch_k,
        "stoch_d": stoch_d,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "bb_mid": latest["BB_Mid"] if pd.notna(latest["BB_Mid"]) else None,
        "bb_width": bb_width,
        "bb_percent": bb_percent,
        "massive_move_recent": massive_move_recent,
        "candle_volatility_high": candle_volatility_high,
        "candle_bodies_stable": candle_bodies_stable,
        "macd_bullish_crossover": macd_bullish_crossover,
        "macd_bearish_crossover": macd_bearish_crossover,
        "stoch_oversold": stoch_oversold,
        "stoch_overbought": stoch_overbought,
        "price_near_bb_lower": price_near_bb_lower,
        "price_near_bb_upper": price_near_bb_upper,
        "bb_contracting": bb_contracting,
        "bb_expanding": bb_expanding,
        "volume_spike_recent": volume_spike_recent
    }

# --- Predictor Functions (consolidated and enhanced) ---

def predict_future_price(df: pd.DataFrame, current_price: float, hours_ahead: float = 1):
    """
    Predicts the future price using Facebook Prophet.
    """
    if df.empty or 'close' not in df.columns or len(df) < 50: # Increased minimum data points for Prophet
        print("Warning: Not enough data in DataFrame for accurate Prophet prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    prophet_df = df.reset_index()[['timestamp', 'close']].rename(columns={'timestamp': 'ds', 'close': 'y'})
    prophet_df['y'] = pd.to_numeric(prophet_df['y'], errors='coerce')
    prophet_df.dropna(subset=['y'], inplace=True)

    if prophet_df.empty or len(prophet_df) < 50:
        print("Warning: 'close' column has insufficient numeric data for Prophet prediction after cleaning. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Initialize and fit Prophet model with adjusted parameters
    model = Prophet(
        daily_seasonality=True,
        weekly_seasonality=False, # Crypto often doesn't have strong weekly seasonality on 1hr
        yearly_seasonality=False,
        changepoint_prior_scale=0.1 # Increased flexibility for trend changes
    )
    try:
        model.fit(prophet_df)
    except Exception as e:
        print(f"Error fitting Prophet model: {e}. Returning current price as projected.")
        return current_price, 0.0, current_price

    future = model.make_future_dataframe(periods=int(hours_ahead), freq='H')
    forecast = model.predict(future)
    projected_price = forecast['yhat'].iloc[-1]

    last_known_price = prophet_df['y'].iloc[-1]
    total_predicted_change = projected_price - last_known_price
    avg_delta = total_predicted_change / hours_ahead if hours_ahead > 0 else 0.0

    projected_price = max(0.0, projected_price)

    return round(projected_price, 2), round(avg_delta, 2), current_price


def recommend_probo_vote_for_target(df: pd.DataFrame, current_price: float, sentiment_score: float, target_price: float, target_time_str: str):
    """
    Recommends a 'YES' or 'NO' vote for a Probo outcome based on projected price and sentiment.
    """
    now_utc = datetime.utcnow()
    target_time_only = datetime.strptime(target_time_str, "%H:%M").time()
    target_datetime_utc = now_utc.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)
    
    if target_datetime_utc < now_utc:
        target_datetime_utc += timedelta(days=1)

    hours_remaining = (target_datetime_utc - now_utc).total_seconds() / 3600
    hours_remaining = max(0.25, round(hours_remaining, 2))

    sentiment = sentiment_score
    projected, delta, current = predict_future_price(df, current_price, hours_remaining)

    if projected >= target_price and sentiment >= -0.1: # Sentiment not strongly negative
        vote = "YES"
    else:
        vote = "NO"

    result = {
        "current_price": current,
        "avg_delta_per_hour": delta,
        "hours_remaining": hours_remaining,
        "projected_price": projected,
        "sentiment": sentiment,
        "target_price": target_price,
        "target_time": target_time_str,
        "vote": vote
    }
    return result

# --- Flask App Endpoints ---

def load_initial_data():
    """Fetches and processes initial market data and sentiment for both BTC and ETH."""
    global btc_market_data_df, btc_current_price, btc_sentiment_score, btc_market_conditions
    global eth_market_data_df, eth_current_price, eth_sentiment_score, eth_market_conditions

    # Helper function to create default market conditions
    def get_default_market_conditions():
        return {k: None for k in [
            "bullish_trend", "oversold", "overbought", "rsi", "ema_20", "ema_50",
            "macd", "macd_signal", "macd_hist", "stoch_k", "stoch_d",
            "bb_upper", "bb_lower", "bb_mid", "bb_width", "bb_percent",
            "massive_move_recent", "candle_volatility_high", "candle_bodies_stable",
            "macd_bullish_crossover", "macd_bearish_crossover",
            "stoch_oversold", "stoch_overbought",
            "price_near_bb_lower", "price_near_bb_upper",
            "bb_contracting", "bb_expanding", "volume_spike_recent"
        ]}

    # --- Load BTC Data ---
    try:
        print("Fetching BTC OHLCV data...")
        df_btc = fetch_ohlcv(symbol="BTCUSDT", limit=200) # Increased limit for better indicator calculation
        if df_btc.empty:
            print("Failed to fetch BTC OHLCV data. Setting defaults.")
            btc_market_data_df = pd.DataFrame()
            btc_current_price = 0.0
            btc_sentiment_score = 0.0
            btc_market_conditions = get_default_market_conditions()
        else:
            print("Adding technical indicators for BTC...")
            df_btc = add_technical_indicators(df_btc)
            btc_market_data_df = df_btc

            print("Getting current BTC price...")
            btc_current_price = get_current_price(symbol="BTCUSDT")

            print("Getting Bitcoin sentiment...")
            btc_sentiment_score = get_crypto_sentiment(crypto_name="bitcoin")

            print("Interpreting BTC market conditions...")
            btc_market_conditions = interpret_market_conditions(btc_market_data_df)
            print("BTC Data loaded successfully.")
    except Exception as e:
        print(f"Error loading initial BTC data: {e}")
        btc_market_data_df = pd.DataFrame()
        btc_current_price = 0.0
        btc_sentiment_score = 0.0
        btc_market_conditions = get_default_market_conditions()

    # --- Load ETH Data ---
    try:
        print("Fetching ETH OHLCV data...")
        df_eth = fetch_ohlcv(symbol="ETHUSDT", limit=200) # Increased limit
        if df_eth.empty:
            print("Failed to fetch ETH OHLCV data. Setting defaults.")
            eth_market_data_df = pd.DataFrame()
            eth_current_price = 0.0
            eth_sentiment_score = 0.0
            eth_market_conditions = get_default_market_conditions()
        else:
            print("Adding technical indicators for ETH...")
            df_eth = add_technical_indicators(df_eth)
            eth_market_data_df = df_eth

            print("Getting current ETH price...")
            eth_current_price = get_current_price(symbol="ETHUSDT")

            print("Getting Ethereum sentiment...")
            eth_sentiment_score = get_crypto_sentiment(crypto_name="ethereum")

            print("Interpreting ETH market conditions...")
            eth_market_conditions = interpret_market_conditions(df_eth)
            print("ETH Data loaded successfully.")
    except Exception as e:
        print(f"Error loading initial ETH data: {e}")
        eth_market_data_df = pd.DataFrame()
        eth_current_price = 0.0
        eth_sentiment_score = 0.0
        eth_market_conditions = get_default_market_conditions()

# Load data when the Flask app starts
with app.app_context():
    load_initial_data()

@app.route('/api/market_data', methods=['GET'])
def get_market_data():
    """Returns current market data for both BTC and ETH."""
    load_initial_data() # Always refresh data for real-time feel

    response_data = {
        "BTC": {
            "current_price": btc_current_price,
            "sentiment_score": btc_sentiment_score,
            "market_conditions": btc_market_conditions,
            "chart_data": []
        },
        "ETH": {
            "current_price": eth_current_price,
            "sentiment_score": eth_sentiment_score,
            "market_conditions": eth_market_conditions,
            "chart_data": []
        }
    }

    # Convert BTC DataFrame to JSON serializable format
    if btc_market_data_df is not None and not btc_market_data_df.empty:
        chart_data_btc = btc_market_data_df[[
            'open', 'high', 'low', 'close', 'volume', 'EMA_20', 'EMA_50',
            'MACD', 'MACD_Signal', 'MACD_Hist', 'STOCH_K', 'STOCH_D',
            'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent'
        ]].reset_index()
        chart_data_btc = chart_data_btc.replace({np.nan: None})
        response_data["BTC"]["chart_data"] = chart_data_btc.to_dict(orient='records')
        for item in response_data["BTC"]["chart_data"]:
            item['timestamp'] = item['timestamp'].isoformat() if pd.notna(item['timestamp']) else None
    else:
        print("BTC market data not available for chart.")

    # Convert ETH DataFrame to JSON serializable format
    if eth_market_data_df is not None and not eth_market_data_df.empty:
        chart_data_eth = eth_market_data_df[[
            'open', 'high', 'low', 'close', 'volume', 'EMA_20', 'EMA_50',
            'MACD', 'MACD_Signal', 'MACD_Hist', 'STOCH_K', 'STOCH_D',
            'BB_Upper', 'BB_Lower', 'BB_Mid', 'BB_Width', 'BB_Percent'
        ]].reset_index()
        chart_data_eth = chart_data_eth.replace({np.nan: None})
        response_data["ETH"]["chart_data"] = chart_data_eth.to_dict(orient='records')
        for item in response_data["ETH"]["chart_data"]:
            item['timestamp'] = item['timestamp'].isoformat() if pd.notna(item['timestamp']) else None
    else:
        print("ETH market data not available for chart.")

    return jsonify(response_data)

@app.route('/api/predict', methods=['POST'])
def predict_outcome():
    """Performs prediction for the selected cryptocurrency."""
    data = request.get_json()
    target_price = data.get('target_price')
    target_time_str = data.get('target_time') # HH:MM in IST
    currency = data.get('currency', 'BTC').upper() # Default to BTC if not specified

    if not target_price or not target_time_str or currency not in ['BTC', 'ETH']:
        return jsonify({"error": "Missing target_price, target_time, or invalid currency"}), 400

    load_initial_data() # Ensure market data is loaded and fresh

    df_to_use = None
    current_price_to_use = 0.0
    sentiment_to_use = 0.0 # This variable holds the sentiment score from the global store
    market_conditions_to_use = {}
    crypto_name_full = ""

    if currency == 'BTC':
        df_to_use = btc_market_data_df
        current_price_to_use = btc_current_price
        sentiment_to_use = btc_sentiment_score
        market_conditions_to_use = btc_market_conditions
        crypto_name_full = "Bitcoin"
    elif currency == 'ETH':
        df_to_use = eth_market_data_df
        current_price_to_use = eth_current_price
        sentiment_to_use = eth_sentiment_score
        market_conditions_to_use = eth_market_conditions
        crypto_name_full = "Ethereum"

    if df_to_use is None or df_to_use.empty:
        return jsonify({"error": f"Market data not available for {currency} prediction"}), 500

    try:
        ist_timezone = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist_timezone)
        target_time_only = datetime.strptime(target_time_str, "%H:%M").time()
        target_datetime_ist = now_ist.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)

        if target_datetime_ist < now_ist:
            target_datetime_ist += timedelta(days=1)

        target_datetime_utc = target_datetime_ist.astimezone(pytz.utc)
        hours_remaining = (target_datetime_utc - datetime.utcnow().replace(tzinfo=pytz.utc)).total_seconds() / 3600
        hours_remaining = max(0.25, round(hours_remaining, 2))

        result = recommend_probo_vote_for_target(
            df=df_to_use,
            current_price=current_price_to_use,
            sentiment_score=sentiment_to_use, # Pass this sentiment to the prediction function
            target_price=target_price,
            target_time_str=target_datetime_utc.strftime("%H:%M") 
        )
        result['hours_remaining'] = hours_remaining
        result['target_time_ist'] = target_time_str # Keep original IST string for frontend display
        result['currency'] = currency # Add currency to result

        # Define sentiment_for_advisor here, *after* result is populated
        # This sentiment_for_advisor will be the (potentially rounded) sentiment from the prediction logic's result
        sentiment_for_advisor = result['sentiment']

        # Retrieve stoch_k and stoch_d from market_conditions_to_use for confidence advisor calculations
        stoch_k = market_conditions_to_use.get('stoch_k')
        stoch_d = market_conditions_to_use.get('stoch_d')

        # --- Evaluate Trust Conditions (12 signals) ---
        trust_conditions_eval = {
            'time_expiry_lt_2hr': hours_remaining >= 0.25 and hours_remaining < 2, # Must be active and <2hr
            'trending_cleanly': market_conditions_to_use['bullish_trend'] is True and market_conditions_to_use['macd_bearish_crossover'] is False,
            'sentiment_strong': abs(sentiment_for_advisor) > 0.2, # Use the correctly defined sentiment_for_advisor
            'rsi_neutral': market_conditions_to_use['rsi'] is not None and 30 <= market_conditions_to_use['rsi'] <= 70,
            'no_major_news_expected': abs(sentiment_for_advisor) > 0.05, # Proxy for market conviction, not flat sentiment
            'candle_bodies_stable_not_volatile': market_conditions_to_use['candle_bodies_stable'] is True and market_conditions_to_use['candle_volatility_high'] is False,
            'macd_bullish_crossover_confirmed': market_conditions_to_use['macd_bullish_crossover'] is True, # Already implies hist > 0 from definition
            'stoch_oversold_bullish_cross': market_conditions_to_use['stoch_oversold'] is True and (stoch_k is not None and stoch_d is not None and stoch_k > stoch_d),
            'price_near_bb_lower': market_conditions_to_use['price_near_bb_lower'] is True,
            'no_massive_move_recent': market_conditions_to_use['massive_move_recent'] is False,
            'bb_stable': market_conditions_to_use['bb_contracting'] is False and market_conditions_to_use['bb_expanding'] is False,
            'no_volume_spike_recent': market_conditions_to_use['volume_spike_recent'] is False
        }
        trust_signals = sum(1 for k, v in trust_conditions_eval.items() if v)

        # --- Evaluate Caution Conditions (11 flags as per UI structure) ---
        caution_conditions_eval = {
            'target_time_gt_3hr': hours_remaining > 3,
            'btc_massive_move': market_conditions_to_use['massive_move_recent'] is True,
            'rsi_extreme': market_conditions_to_use['overbought'] is True or market_conditions_to_use['oversold'] is True,
            'sentiment_conflicting': abs(sentiment_for_advisor) < 0.05, # Use the correctly defined sentiment_for_advisor
            'big_news_coming_or_volume_spike': abs(sentiment_for_advisor) < 0.05 or market_conditions_to_use['volume_spike_recent'] is True,
            'candle_volatility_high': market_conditions_to_use['candle_volatility_high'] is True,
            'macd_bearish_crossover_confirmed': market_conditions_to_use['macd_bearish_crossover'] is True, # Already implies hist < 0 from definition
            'stoch_overbought_bearish_cross': market_conditions_to_use['stoch_overbought'] is True and (stoch_k is not None and stoch_d is not None and stoch_k < stoch_d),
            'price_near_bb_upper_or_bb_volatile': market_conditions_to_use['price_near_bb_upper'] is True or market_conditions_to_use['bb_contracting'] is True or market_conditions_to_use['bb_expanding'] is True,
            'bb_volatile': market_conditions_to_use['bb_contracting'] is True or market_conditions_to_use['bb_expanding'] is True, # Distinct general volatility flag
            'volume_spike_recent': market_conditions_to_use['volume_spike_recent'] is True # Distinct volume spike flag
        }
        caution_flags = sum(1 for k, v in caution_conditions_eval.items() if v)

        # Determine overall advice
        if trust_signals >= 7 and caution_flags < 4:
            advice_message = "üîê Confidence: *GO with the vote!* Strong signals align."
        elif caution_flags >= 4:
            advice_message = "üîê Confidence: *SKIP the trade or WAIT!* High uncertainty detected."
        else:
            advice_message = "üîê Confidence: *Proceed with caution or wait for clearer signals.* Mixed indicators."

        result['confidence_advisor'] = {
            'trust_signals_count': trust_signals,
            'caution_flags_count': caution_flags,
            'advice_message': advice_message,
            'trust_conditions': trust_conditions_eval,
            'caution_conditions': caution_conditions_eval
        }
        
        return jsonify(result)
    except ValueError as ve:
        return jsonify({"error": f"Invalid input or time format: {ve}"}), 400
    except Exception as e:
        print(f"An error occurred during prediction: {e}")
        return jsonify({"error": f"An internal server error occurred during prediction: {e}"}), 500

# --- NEW: Gemini AI Prediction Endpoint ---
@app.route('/api/gemini_ai_vote', methods=['POST'])
def gemini_ai_vote():
    if not gemini_prediction_model:
        return jsonify({"error": "Gemini prediction model not initialized."}), 500

    data = request.get_json()
    target_price = data.get('target_price')
    target_time_str = data.get('target_time') # HH:MM in IST
    currency = data.get('currency', 'BTC').upper()

    if not target_price or not target_time_str or currency not in ['BTC', 'ETH']:
        return jsonify({"error": "Missing target_price, target_time, or invalid currency"}), 400

    # Ensure market data is loaded and fresh
    load_initial_data() 

    df_to_use = None
    current_price_to_use = 0.0
    sentiment_to_use = 0.0
    market_conditions_to_use = {}
    prophet_projected_price = 0.0
    prophet_avg_delta = 0.0

    if currency == 'BTC':
        df_to_use = btc_market_data_df
        current_price_to_use = btc_current_price
        sentiment_to_use = btc_sentiment_score
        market_conditions_to_use = btc_market_conditions
    elif currency == 'ETH':
        df_to_use = eth_market_data_df
        current_price_to_use = eth_current_price
        sentiment_to_use = eth_sentiment_score
        market_conditions_to_use = eth_market_conditions
    
    if df_to_use is None or df_to_use.empty:
        return jsonify({"error": f"Market data not available for {currency} AI prediction"}), 500

    try:
        ist_timezone = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist_timezone)
        target_time_only = datetime.strptime(target_time_str, "%H:%M").time()
        target_datetime_ist = now_ist.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)

        if target_datetime_ist < now_ist:
            target_datetime_ist += timedelta(days=1)

        target_datetime_utc = target_datetime_ist.astimezone(pytz.utc)
        hours_remaining = (target_datetime_utc - datetime.utcnow().replace(tzinfo=pytz.utc)).total_seconds() / 3600
        hours_remaining = max(0.25, round(hours_remaining, 2))

        # Get Prophet prediction as part of context for Gemini
        prophet_projected_price, prophet_avg_delta, _ = predict_future_price(df_to_use, current_price_to_use, hours_remaining)

        # Prepare prompt for Gemini
        prompt = f"""
        You are an expert cryptocurrency market analyst and a Probo event predictor. Your task is to analyze the provided market data, technical indicators, and sentiment, then make a highly confident recommendation (YES/NO) for a Probo event based on whether the {currency} price will be AT or ABOVE a target price by a specific target time.

        Here is the current market context for {currency}:

        --- Market Data ---
        Current Price: ${current_price_to_use:.2f}
        Time Remaining until Target: {hours_remaining:.2f} hours
        Target Price for Prediction: ${target_price:.2f}
        Target Time (IST): {target_time_str}
        Sentiment Score (from news analysis, -1.0 to 1.0): {sentiment_to_use:.3f}

        --- Technical Indicators (Latest Candle) ---
        RSI: {market_conditions_to_use.get('rsi', 'N/A'):.2f} (30=oversold, 70=overbought)
        EMA 20: {market_conditions_to_use.get('ema_20', 'N/A'):.2f}
        EMA 50: {market_conditions_to_use.get('ema_50', 'N/A'):.2f}
        MACD: {market_conditions_to_use.get('macd', 'N/A'):.2f}
        MACD Signal: {market_conditions_to_use.get('macd_signal', 'N/A'):.2f}
        MACD Histogram: {market_conditions_to_use.get('macd_hist', 'N/A'):.2f} (Positive = bullish momentum, Negative = bearish momentum)
        Stochastic %K: {market_conditions_to_use.get('stoch_k', 'N/A'):.2f} (20=oversold, 80=overbought)
        Stochastic %D: {market_conditions_to_use.get('stoch_d', 'N/A'):.2f}
        Bollinger Bands (Upper/Mid/Lower): {market_conditions_to_use.get('bb_upper', 'N/A'):.2f} / {market_conditions_to_use.get('bb_mid', 'N/A'):.2f} / {market_conditions_to_use.get('bb_lower', 'N/A'):.2f}
        Bollinger Band Width: {market_conditions_to_use.get('bb_width', 'N/A'):.2f}
        Bollinger Band %B: {market_conditions_to_use.get('bb_percent', 'N/A'):.2f} (0=lower band, 0.5=mid band, 1=upper band)

        --- Market Conditions / Interpretations ---
        Bullish Trend (EMA20 > EMA50): {market_conditions_to_use.get('bullish_trend', 'N/A')}
        RSI Oversold (<30): {market_conditions_to_use.get('oversold', 'N/A')}
        RSI Overbought (>70): {market_conditions_to_use.get('overbought', 'N/A')}
        MACD Bullish Crossover (MACD > Signal, Hist > 0): {market_conditions_to_use.get('macd_bullish_crossover', 'N/A')}
        MACD Bearish Crossover (MACD < Signal, Hist < 0): {market_conditions_to_use.get('macd_bearish_crossover', 'N/A')}
        Stochastic Oversold (%K/%D < 20 and K > D): {market_conditions_to_use.get('stoch_oversold', 'N/A')}
        Stochastic Overbought (%K/%D > 80 and K < D): {market_conditions_to_use.get('stoch_overbought', 'N/A')}
        Price Near BB Lower Band: {market_conditions_to_use.get('price_near_bb_lower', 'N/A')}
        Price Near BB Upper Band: {market_conditions_to_use.get('price_near_bb_upper', 'N/A')}
        Bollinger Bands Contracting (getting narrower): {market_conditions_to_use.get('bb_contracting', 'N/A')}
        Bollinger Bands Expanding (getting wider): {market_conditions_to_use.get('bb_expanding', 'N/A')}
        Massive Price Move Recently (past 4 hours): {market_conditions_to_use.get('massive_move_recent', 'N/A')}
        High Candle Volatility (large wicks): {market_conditions_to_use.get('candle_volatility_high', 'N/A')}
        Stable Candle Bodies (small wicks, decent body): {market_conditions_to_use.get('candle_bodies_stable', 'N/A')}
        Recent Volume Spike: {market_conditions_to_use.get('volume_spike_recent', 'N/A')}

        --- Prophet Model Projection ---
        Prophet Projected Price by Target Time: ${prophet_projected_price:.2f}
        Prophet Average Price Change per Hour: ${prophet_avg_delta:.2f}

        Based on all the above information, including the current price, target price, time remaining, sentiment, all technical indicators, and the interpreted market conditions, should one vote YES or NO on the Probo event?

        Your answer MUST be structured as follows:
        VOTE: [YES/NO]
        REASONING: [A concise, yet comprehensive explanation of why you recommend this vote, referencing specific data points and indicators from the provided context. Consider the interplay of trend, momentum, volatility, and sentiment. Also, comment on the Prophet projection and whether your analysis supports or contradicts it.]
        """
        # print("Gemini Prompt:\n", prompt) # For debugging

        response = gemini_prediction_model.generate_content(prompt)
        ai_response_text = response.text.strip()
        # print("Gemini Raw Response:\n", ai_response_text) # For debugging

        ai_vote = "N/A"
        ai_reasoning = "Could not parse AI response."

        if ai_response_text.startswith("VOTE:"):
            lines = ai_response_text.split('\n')
            for line in lines:
                if line.startswith("VOTE:"):
                    ai_vote = line.replace("VOTE:", "").strip()
                elif line.startswith("REASONING:"):
                    ai_reasoning = line.replace("REASONING:", "").strip()
                    # Capture the rest of the lines as well for multi-line reasoning
                    reasoning_lines = lines[lines.index(line):]
                    ai_reasoning = "\n".join([l.replace("REASONING:", "").strip() if l.startswith("REASONING:") else l.strip() for l in reasoning_lines])
                    break # Stop after finding reasoning

        return jsonify({
            "ai_vote": ai_vote,
            "ai_reasoning": ai_reasoning,
            "status": "success"
        })

    except Exception as e:
        print(f"Error during Gemini AI prediction: {e}")
        return jsonify({"error": f"An internal server error occurred during AI prediction: {e}"}), 500

# --- NEW: Gemini AI Chatbot Endpoint ---
@app.route('/api/ai_chat', methods=['POST'])
def ai_chat():
    if not gemini_chat_model:
        return jsonify({"error": "Gemini chat model not initialized."}), 500

    user_message = request.form.get('message')
    files = request.files.getlist('files')

    if not user_message and not files:
        return jsonify({"error": "No message or files provided."}), 400

    content = []
    if user_message:
        content.append(user_message)

    for file in files:
        try:
            filename = file.filename
            file_bytes = file.read()
            mime_type = file.mimetype

            if mime_type.startswith('image/'):
                img = Image.open(io.BytesIO(file_bytes))
                content.append(img)
            elif mime_type == 'text/plain' or 'csv' in mime_type: # Basic text/CSV
                content.append(f"File '{filename}' content:\n{file_bytes.decode('utf-8')}")
            else:
                # Placeholder for other document types
                content.append(f"Received file '{filename}' ({mime_type}). I can only process text and images directly. For complex formats like PDF, DOCX, XLSX, dedicated libraries would be needed to extract meaningful content.")
                print(f"Unsupported file type for direct processing: {mime_type} ({filename})")
                
        except Exception as e:
            print(f"Error processing uploaded file {file.filename}: {e}")
            content.append(f"Error processing file '{file.filename}': {e}")
    
    if not content:
        return jsonify({"error": "No content to send to AI (message or files failed to process)."}), 400

    try:
        response = gemini_chat_model.generate_content(content)
        return jsonify({"ai_response": response.text.strip()})
    except Exception as e:
        print(f"Error during Gemini AI chat: {e}")
        return jsonify({"error": f"An internal server error occurred during AI chat: {e}"}), 500


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

--- END FILE: backend_app.py ---

--- START FILE: btc_data.py ---

# btc_data.py

import requests
import pandas as pd
import time
from ta.momentum import RSIIndicator
from ta.trend import EMAIndicator

BINANCE_BASE_URL = "https://api.binance.com"

def fetch_ohlcv(symbol="BTCUSDT", interval="1h", limit=100):
    """
    Fetches OHLCV (Open, High, Low, Close, Volume) data from Binance.

    Args:
        symbol (str): The trading pair symbol (e.g., "BTCUSDT").
        interval (str): The candlestick interval (e.g., "1h", "4h", "1d").
        limit (int): The number of data points to fetch.

    Returns:
        pandas.DataFrame: DataFrame containing OHLCV data with timestamp as index.
                          Returns an empty DataFrame on failure.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    
    try:
        response = requests.get(url, params=params, timeout=10) # Add timeout
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        data = response.json()

        if not data:
            print(f"No data received for {symbol} with interval {interval}.")
            return pd.DataFrame()

        df = pd.DataFrame(data, columns=[
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_buy_base_vol", "taker_buy_quote_vol", "ignore"
        ])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
        df.set_index("timestamp", inplace=True)
        # Convert relevant columns to numeric, coercing errors to NaN
        df["open"] = pd.to_numeric(df["open"], errors='coerce')
        df["high"] = pd.to_numeric(df["high"], errors='coerce')
        df["low"] = pd.to_numeric(df["low"], errors='coerce')
        df["close"] = pd.to_numeric(df["close"], errors='coerce')
        df["volume"] = pd.to_numeric(df["volume"], errors='coerce')
        
        # Drop rows with any NaN values that resulted from coercion
        df.dropna(subset=["open", "high", "low", "close", "volume"], inplace=True)

        return df[["open", "high", "low", "close", "volume"]]
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OHLCV data from Binance: {e}")
        return pd.DataFrame()
    except ValueError as e:
        print(f"Error parsing JSON data from Binance: {e}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in fetch_ohlcv: {e}")
        return pd.DataFrame()

def add_technical_indicators(df):
    """
    Adds Relative Strength Index (RSI), EMA 20, and EMA 50 to the DataFrame.
    Also adds candle body size and wick ratio for volatility analysis.

    Args:
        df (pandas.DataFrame): DataFrame with 'close' prices.

    Returns:
        pandas.DataFrame: DataFrame with added technical indicator columns.
    """
    if df.empty or 'close' not in df.columns or 'open' not in df.columns or 'high' not in df.columns or 'low' not in df.columns:
        print("DataFrame is empty or missing required OHLCV columns for indicator calculation.")
        return df

    # Ensure relevant columns are numeric
    for col in ['open', 'high', 'low', 'close']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    df.dropna(subset=['open', 'high', 'low', 'close'], inplace=True)

    if df.empty:
        return df

    # Calculate RSI
    if len(df) >= 14:
        rsi = RSIIndicator(df["close"], window=14).rsi()
        df["RSI"] = rsi
    else:
        df["RSI"] = float('nan')

    # Calculate EMA 20
    if len(df) >= 20:
        ema_20 = EMAIndicator(df["close"], window=20).ema_indicator()
        df["EMA_20"] = ema_20
    else:
        df["EMA_20"] = float('nan')

    # Calculate EMA 50
    if len(df) >= 50:
        ema_50 = EMAIndicator(df["close"], window=50).ema_indicator()
        df["EMA_50"] = ema_50
    else:
        df["EMA_50"] = float('nan')

    # --- New: Candle Volatility Metrics ---
    # Candle body size (absolute difference between open and close)
    df['body_size'] = abs(df['close'] - df['open'])

    # Total candle range (High - Low)
    df['candle_range'] = df['high'] - df['low']

    # Upper wick: High - max(Open, Close)
    df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
    # Lower wick: min(Open, Close) - Low
    df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']

    # Total wick size
    df['total_wick_size'] = df['upper_wick'] + df['lower_wick']

    # Wick to body ratio (avoid division by zero)
    df['wick_to_body_ratio'] = df.apply(
        lambda row: row['total_wick_size'] / row['body_size'] if row['body_size'] > 0 else (1.0 if row['total_wick_size'] > 0 else 0.0),
        axis=1
    )
    # --- End New Metrics ---

    return df

def get_current_price(symbol="BTCUSDT"):
    """
    Fetches the current price of a given symbol from Binance.

    Args:
        symbol (str): The trading pair symbol (e.g., "BTCUSDT").

    Returns:
        float: The current price. Returns 0.0 on failure.
    """
    url = f"{BINANCE_BASE_URL}/api/v3/ticker/price?symbol={symbol}"
    try:
        response = requests.get(url, timeout=5) # Add timeout
        response.raise_for_status()
        return float(response.json()["price"])
    except requests.exceptions.RequestException as e:
        print(f"Error fetching current price from Binance: {e}")
        return 0.0
    except (ValueError, KeyError) as e:
        print(f"Error parsing current price data: {e}")
        return 0.0
    except Exception as e:
        print(f"An unexpected error occurred in get_current_price: {e}")
        return 0.0

if __name__ == "__main__":
    print("--- Testing btc_data.py ---")
    df = fetch_ohlcv()
    if not df.empty:
        df = add_technical_indicators(df)
        print("\nLast 5 OHLCV with Indicators and Volatility Metrics:")
        print(df[['close', 'RSI', 'EMA_20', 'EMA_50', 'body_size', 'candle_range', 'wick_to_body_ratio']].tail())
    else:
        print("Failed to fetch OHLCV data for testing.")

    current_price = get_current_price()
    print(f"\nCurrent BTC Price: ${current_price}")



--- END FILE: btc_data.py ---

--- START FILE: combine_project.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combine_project.py ---

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Probo Predictor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Plotly.js CDN for charting -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Favicon links (ensure these files are in your root directory) -->
    <!-- You might want to create and include proper favicons if deploying -->
    <!-- <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> -->
    <!-- <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> -->
    <!-- <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> -->
    <!-- <link rel="manifest" href="/site.webmanifest"> -->
    <!-- <link rel="shortcut icon" href="/favicon.ico"> -->

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background */
            color: #DAA520; /* Goldenrod text for general content */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            overflow-y: auto; /* Allow scrolling */
        }
        .container {
            background-color: #1a1a1a; /* Slightly lighter black for container */
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 800px; /* Max width for desktop */
            margin: 1rem; /* Margin for mobile and desktop */
            box-sizing: border-box;
        }
        h1, h2, h3, h4 {
            color: #FFD700; /* Gold for headings */
        }
        input[type="number"], input[type="time"], button, select, textarea {
            background-color: #222222; /* Darker grey for inputs */
            border: 1px solid #444444; /* Darker grey border */
            color: #FFD700; /* Gold text */
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
        }
        input[type="number"]:focus, input[type="time"]:focus, button:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #FFD700; /* Gold border on focus */
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3); /* Gold shadow on focus */
        }
        button {
            cursor: pointer;
            font-weight: 600;
            background-color: #FFD700; /* Gold button */
            border-color: #FFD700;
            color: #000000; /* Black text on gold button */
            display: flex; /* Enable flex for icon and text alignment */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
        }
        button:hover {
            background-color: #DAA520; /* Darker gold on hover */
            border-color: #DAA520;
        }
        .metric-value {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            color: #FFD700; /* Gold */
        }
        .expander-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem; /* Added horizontal padding */
            font-weight: 600;
            color: #DAA520; /* Goldenrod */
            border-bottom: 1px solid #444444;
            transition: background-color 0.2s ease-in-out, border-radius 0.2s ease-in-out;
        }
        .expander-header:hover {
            background-color: #2a2a2a; /* Slightly darker grey on hover */
            border-radius: 0.5rem; /* Apply border-radius on hover */
        }
        .expander-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 0 1rem; /* Horizontal padding always, vertical only when expanded */
        }
        .expander-content.expanded {
            max-height: 9999px; /* Large enough value */
            padding: 1rem;
        }
        .arrow {
            transition: transform 0.3s ease-out;
        }
        .arrow.expanded {
            transform: rotate(90deg);
        }
        .plotly-graph-div {
            border-radius: 0.75rem;
            overflow: hidden;
            background-color: #222222; /* Darker background for chart area */
        }
        .plotly .modebar {
            background-color: #222222 !important;
            border-radius: 0.5rem;
            padding: 0.25rem;
        }
        .plotly .modebar-btn {
            color: #FFD700 !important;
        }
        .plotly .modebar-btn:hover {
            background-color: #444444 !important;
        }
        /* Custom message boxes for gold/black theme */
        .success-message {
            background-color: #2a3620; /* Darker green */
            color: #d4edda; /* Lighter green */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .warning-message {
            background-color: #4d3a20; /* Darker orange */
            color: #fce8d4; /* Lighter orange */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .info-message {
            background-color: #20364d; /* Darker blue */
            color: #d4e8fc; /* Lighter blue */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        .error-message {
            background-color: #4d2020; /* Darker red */
            color: #fcd4d4; /* Lighter red */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #FFD700; /* Gold */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Text colors for YES/NO in confidence advisor */
        .text-green-400 { color: #82E0AA; } /* Adjusted green for better contrast */
        .text-red-400 { color: #F1948A; } /* Adjusted red for better contrast */
        .check-icon { color: #28B463; } /* Stronger green for checkmark */
        .cross-icon { color: #E74C3C; } /* Stronger red for crossmark */

        /* Chatbot specific styles */
        #chat-window {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            border-radius: 0.5rem;
            padding: 1rem;
            background-color: #222222;
        }
        .chat-message {
            margin-bottom: 0.75rem;
            display: flex;
        }
        .chat-message.user {
            justify-content: flex-end;
        }
        .chat-message.ai {
            justify-content: flex-start;
        }
        .chat-bubble {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            line-height: 1.4;
        }
        .chat-bubble.user {
            background-color: #FFD700; /* Gold bubble for user */
            color: #000000; /* Black text */
            border-bottom-right-radius: 0;
        }
        .chat-bubble.ai {
            background-color: #333333; /* Darker grey bubble for AI */
            color: #FFD700; /* Gold text */
            border-bottom-left-radius: 0;
        }
        .chat-file-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            display: block;
        }
        .file-upload-list {
            list-style: none;
            padding: 0;
            margin-top: 0.5rem;
        }
        .file-upload-list li {
            background-color: #333;
            padding: 0.4rem 0.6rem;
            border-radius: 0.3rem;
            margin-bottom: 0.3rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .file-upload-list li .remove-file {
            cursor: pointer;
            color: #F1948A;
            margin-left: 0.5rem;
        }

        /* Floating Chatbot styles */
        #floating-chat-window-content {
            width: 384px; /* Default Tailwind w-96 */
            max-height: 80vh; /* Max height for the chatbot window */
            max-width: calc(100vw - 2rem); /* Max width for mobile screens */
            transition: all 0.3s ease-in-out;
        }
        #chat-toggle-btn {
            background-color: #FFD700;
            color: #000000;
            padding: 1rem;
            border-radius: 9999px; /* Tailwind 'rounded-full' */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* Tailwind 'text-2xl' */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            margin-bottom: 0.5rem; /* Space between button and chat window */
            min-width: 56px; /* Ensure button is round */
            min-height: 56px; /* Ensure button is round */
        }
        #chat-toggle-btn:hover {
            background-color: #DAA520;
        }
        /* Mobile adjustments for floating chatbot */
        @media (max-width: 768px) {
            #floating-chat-window-content {
                width: calc(100vw - 2rem); /* Full width on smaller screens, with margin */
                right: 1rem;
                left: 1rem;
            }
            #floating-chatbot-container {
                right: 0.5rem;
                left: 0.5rem;
                bottom: 0.5rem;
                align-items: center; /* Center the button and window on mobile */
            }
        }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6">
            <i class="fas fa-chart-line text-gold-500 mr-3"></i> Crypto Probo Predictor
        </h1>

        <div class="text-center text-gray-400 mb-6">
            <p>Unveiling the future of crypto with advanced analytics. Input your Probo deal details to receive an AI-powered prediction and confidence assessment.</p>
        </div>

        <!-- Currency Selector -->
        <div class="bg-gray-900 p-4 rounded-lg shadow-md mb-6 flex flex-col md:flex-row justify-between items-center">
            <span class="text-xl font-medium text-gray-400 mb-2 md:mb-0">
                <i class="fas fa-coins text-gold-300 mr-2"></i> Select Cryptocurrency:
            </span>
            <div class="flex space-x-4">
                <label class="inline-flex items-center cursor-pointer">
                    <input type="radio" class="form-radio text-yellow-500 h-5 w-5" name="currency" value="BTC" checked>
                    <span class="ml-2 text-gold-300"><i class="fab fa-btc mr-1"></i> Bitcoin (BTC)</span>
                </label>
                <label class="inline-flex items-center cursor-pointer">
                    <input type="radio" class="form-radio text-yellow-500 h-5 w-5" name="currency" value="ETH">
                    <span class="ml-2 text-gold-300"><i class="fab fa-ethereum mr-1"></i> Ethereum (ETH)</span>
                </label>
            </div>
        </div>

        <!-- Current Price Metric -->
        <div class="bg-gray-900 p-4 rounded-lg shadow-md mb-6 flex justify-between items-center">
            <span class="text-xl font-medium text-gray-400">
                <i class="fas fa-sack-dollar text-gold-300 mr-2"></i> Current Price (<span id="current-currency-symbol">BTC</span>)
            </span>
            <span id="current-price-display" class="metric-value">$0.00</span>
            <div id="loading-spinner" class="loader hidden"></div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Prediction Form -->
        <h2 class="text-2xl font-semibold mb-4 text-gold-100">
            <i class="fas fa-crystal-ball text-gold-500 mr-2"></i> Predict Probo Outcome
        </h2>
        <form id="prediction-form" class="space-y-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="target-price" class="block text-sm font-medium text-gray-400 mb-1">Target Price (USDT)</label>
                    <input type="number" id="target-price" value="65000" class="w-full rounded-lg px-4 py-2" step="any">
                </div>
                <div>
                    <label for="target-time" class="block text-sm font-medium text-gray-400 mb-1">Target Time (HH:MM in IST)</label>
                    <input type="time" id="target-time" value="23:00" class="w-full rounded-lg px-4 py-2">
                    <p class="text-xs text-gray-500 mt-1">Current IST: <span id="current-ist-time"></span></p>
                </div>
            </div>
            <button type="submit" class="w-full py-2 rounded-lg text-black font-semibold">
                Get Recommendation <div id="prediction-spinner" class="loader hidden"></div>
            </button>
        </form>

        <div id="prediction-results" class="mt-6 space-y-4">
            <!-- Prediction Summary -->
            <div id="prediction-summary-expander" class="expander-header rounded-lg bg-gray-900">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-chart-pie text-gold-300 mr-2"></i> Prophet Prediction Summary
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="prediction-summary-content" class="expander-content bg-gray-900 rounded-lg">
                <div class="p-4 space-y-2">
                    <p class="text-gold-300"><strong class="text-gold-100">Current Price:</strong> <span id="summary-current-price">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Avg Œî/hr:</strong> <span id="summary-avg-delta">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Time Left:</strong> <span id="summary-time-left">0 hr(s)</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Projected Price:</strong> <span id="summary-projected-price">$0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Sentiment Score:</strong> <span id="summary-sentiment-score">0.00</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Target Time (IST):</strong> <span id="summary-target-time">HH:MM</span></p>
                </div>
            </div>

            <!-- Recommended Vote (Prophet) -->
            <div id="recommended-vote-message" class="hidden text-center text-xl font-bold py-3 px-4 rounded-lg"></div>

            <!-- NEW: Gemini AI Recommended Vote -->
            <div id="gemini-ai-vote-expander" class="expander-header rounded-lg bg-gray-900 mt-4">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-robot text-gold-300 mr-2"></i> Gemini AI Recommendation
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="gemini-ai-vote-content" class="expander-content bg-gray-900 rounded-lg">
                <div class="p-4 space-y-2">
                    <p class="text-gold-300 text-lg"><strong class="text-gold-100">Gemini AI Vote:</strong> <span id="gemini-ai-vote" class="font-bold">N/A</span></p>
                    <p class="text-gold-300"><strong class="text-gold-100">Reasoning:</strong> <span id="gemini-ai-reasoning" class="block whitespace-pre-wrap">N/A</span></p>
                    <div id="gemini-vote-spinner" class="loader hidden mx-auto"></div>
                </div>
            </div>

            <!-- Prediction Confidence Advisor -->
            <hr class="border-gray-800 my-6">
            <h3 class="text-xl font-semibold text-gold-100">
                <i class="fas fa-lightbulb text-gold-500 mr-2"></i> Prediction Confidence Advisor
            </h3>

            <div id="trust-signals-expander" class="expander-header rounded-lg bg-gray-900">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-shield-alt text-green-400 mr-2"></i> Trust Signals
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="trust-signals-content" class="expander-content bg-gray-900 rounded-lg">
                <ul class="list-none text-gold-300 space-y-2 p-4">
                    <li><span id="trust-time-icon"></span> Time to expiry is &lt; 2 hours: <span id="trust-time"></span></li>
                    <li><span id="trust-trend-icon"></span> <span id="trust-currency-name">BTC</span> is trending cleanly (up or down): <span id="trust-trend"></span></li>
                    <li><span id="trust-sentiment-icon"></span> Sentiment score is strongly positive/negative (&gt;0.2): <span id="trust-sentiment"></span></li>
                    <li><span id="trust-rsi-icon"></span> RSI is not extreme (30-70): <span id="trust-rsi"></span></li>
                    <li><span id="trust-news-icon"></span> No major news expected (Sentiment not conflicting): <span id="trust-news"></span></li>
                    <li><span id="trust-stable-candles-icon"></span> Candle bodies are stable (not huge wicks): <span id="trust-stable-candles"></span></li>
                    <li><span id="trust-macd-bullish-icon"></span> MACD shows bullish crossover: <span id="trust-macd-bullish"></span></li>
                    <li><span id="trust-stoch-oversold-icon"></span> Stochastic is oversold (potential rebound): <span id="trust-stoch-oversold"></span></li>
                    <li><span id="trust-bb-lower-icon"></span> Price near lower Bollinger Band (potential support): <span id="trust-bb-lower"></span></li>
                    <li><span id="trust-no-massive-move-icon"></span> No massive move recently: <span id="trust-no-massive-move"></span></li>
                    <li><span id="trust-bb-stable-icon"></span> Bollinger Bands are stable (not squeezing/expanding): <span id="trust-bb-stable"></span></li>
                    <li><span id="trust-no-volume-spike-icon"></span> No recent volume spike: <span id="trust-no-volume-spike"></span></li>
                </ul>
            </div>

            <div id="caution-flags-expander" class="expander-header rounded-lg bg-gray-900">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-2"></i> Caution Flags
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="caution-flags-content" class="expander-content bg-gray-900 rounded-lg">
                <ul class="list-none text-gold-300 space-y-2 p-4">
                    <li><span id="caution-time-icon"></span> Target time is &gt; 3 hours away: <span id="caution-time"></span></li>
                    <li><span id="caution-massive-move-icon"></span> <span id="caution-currency-name">BTC</span> just made a massive move: <span id="caution-massive-move"></span></li>
                    <li><span id="caution-rsi-icon"></span> RSI is &gt; 70 or &lt; 30 (extreme): <span id="caution-rsi"></span></li>
                    <li><span id="caution-sentiment-icon"></span> Sentiment is conflicting (score ‚âà 0): <span id="caution-sentiment"></span></li>
                    <li><span id="caution-big-news-icon"></span> Market Volatility due to News/Events (sentiment conflicting OR volume spike): <span id="caution-big-news"></span></li>
                    <li><span id="caution-volatile-candles-icon"></span> Candle volatility is high (huge wicks): <span id="caution-volatile-candles"></span></li>
                    <li><span id="caution-macd-bearish-icon"></span> MACD shows bearish crossover: <span id="caution-macd-bearish"></span></li>
                    <li><span id="caution-stoch-overbought-icon"></span> Stochastic is overbought (potential reversal): <span id="caution-stoch-overbought"></span></li>
                    <li><span id="caution-bb-upper-contracting-icon"></span> Price near upper Bollinger Band or BB contracting: <span id="caution-bb-upper-contracting"></span></li>
                    <li><span id="caution-bb-volatile-icon"></span> Bollinger Bands are volatile (squeezing/expanding): <span id="caution-bb-volatile"></span></li>
                    <li><span id="caution-volume-spike-icon"></span> Recent volume spike: <span id="caution-volume-spike"></span></li>
                </ul>
            </div>

            <hr class="border-gray-800 my-6">
            <p class="text-gold-300 text-lg"><strong class="text-gold-100">Total Trust Signals Met:</strong> <span id="total-trust-signals" class="text-green-400 font-bold">0</span></p>
            <p class="text-gold-300 text-lg"><strong class="text-gold-100">Total Caution Flags Present:</strong> <span id="total-caution-flags" class="text-red-400 font-bold">0</span></p>
            <div id="pro-tip-message" class="mt-4"></div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Technical Indicators -->
        <div id="technical-indicators-expander" class="expander-header rounded-lg bg-gray-900">
            <span class="text-lg text-gold-100">
                <i class="fas fa-flask text-gold-300 mr-2"></i> Technical Indicators
            </span>
            <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
        </div>
        <div id="technical-indicators-content" class="expander-content bg-gray-900 rounded-lg">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center p-4">
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">RSI</div>
                    <div id="metric-rsi" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">EMA 20</div>
                    <div id="metric-ema20" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">EMA 50</div>
                    <div id="metric-ema50" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">MACD</div>
                    <div id="metric-macd" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">Stoch %K</div>
                    <div id="metric-stochk" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <div class="text-sm text-gray-400">Stoch %D</div>
                    <div id="metric-stochd" class="text-xl font-bold text-gold-300">0.00</div>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg col-span-1 md:col-span-3">
                    <div class="text-sm text-gray-400">Bollinger Bands (Upper/Mid/Lower)</div>
                    <div id="metric-bb" class="text-xl font-bold text-gold-300">0.00 / 0.00 / 0.00</div>
                </div>
            </div>
            <div class="mt-4 text-gold-300 p-4 pt-0 space-y-1">
                <p><strong class="text-gold-100">Trend:</strong> <span id="market-trend"></span></p>
                <p><strong class="text-gold-100">RSI Zone:</strong> <span id="market-rsi-zone"></span></p>
                <p><strong class="text-gold-100">Stochastic Zone:</strong> <span id="market-stoch-zone"></span></p>
                <p><strong class="text-gold-100">Bollinger Band Width:</strong> <span id="metric-bb-width"></span></p>
            </div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Chart -->
        <!-- CHART EXPANDER IS NOW OPEN BY DEFAULT -->
        <div id="chart-expander" class="expander-header rounded-lg bg-gray-900 expanded">
            <span class="text-lg text-gold-100">
                <i class="fas fa-chart-area text-gold-300 mr-2"></i> View Chart
            </span>
            <svg class="arrow w-5 h-5 text-gold-300 expanded" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
        </div>
        <div id="chart-content" class="expander-content bg-gray-900 rounded-lg expanded">
            <div id="candlestick-chart" class="w-full h-[600px] p-4"></div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- NEW: Gemini AI Chatbot (Original static section - will be hidden by JS and moved) -->
        <div id="static-ai-chatbot-section" style="display: none;">
            <div id="ai-chatbot-expander" class="expander-header rounded-lg bg-gray-900 mt-4">
                <span class="text-lg text-gold-100">
                    <i class="fas fa-comments text-gold-300 mr-2"></i> AI Chatbot
                </span>
                <svg class="arrow w-5 h-5 text-gold-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </div>
            <div id="ai-chatbot-content" class="expander-content bg-gray-900 rounded-lg">
                <div id="chat-window" class="mb-4">
                    <div class="chat-message ai">
                        <div class="chat-bubble ai">Hello! I'm your Crypto Probo AI assistant. I can help analyze market data, discuss predictions, or analyze files you upload. What's on your mind?</div>
                    </div>
                </div>
                <div class="file-upload-list" id="uploaded-files-preview"></div>
                <div class="flex flex-col space-y-2">
                    <input type="file" id="chat-file-input" multiple accept="image/*, text/*, .pdf, .csv, .docx, .xlsx" class="w-full text-gold-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-gold-300 hover:file:bg-gray-600"/>
                    <textarea id="chat-input" class="w-full rounded-lg px-4 py-2" rows="3" placeholder="Ask me about crypto, market conditions, or upload a file for analysis..."></textarea>
                    <button id="send-chat-btn" class="w-full py-2 rounded-lg text-black font-semibold">
                        Send Message <div id="chat-spinner" class="loader hidden"></div>
                    </button>
                </div>
                <div id="chat-error-message" class="error-message hidden"></div>
            </div>
        </div>

        <hr class="border-gray-800 my-6">

        <!-- Overlay Feature Explanation -->
        <div class="warning-message text-center mb-6">
            <h3 class="font-bold text-lg mb-2">
                <i class="fas fa-exclamation-circle mr-2"></i> Important Note on Mobile Overlay
            </h3>
            <p class="text-sm">
                The requested feature to scan your phone screen for Probo data and overlay predictions is **not technically possible** within a standard web application due to strict security and privacy policies of web browsers and mobile operating systems (iOS/Android).
            </p>
            <p class="text-sm mt-2">
                Websites are restricted from accessing content outside their own tab. Implementing such a feature would require developing a complex native mobile application with special OS permissions, which is beyond the scope of a web-based project. Please manually input the data from Probo into this tool.
            </p>
        </div>

        <!-- Cheat Sheet Reference -->
        <h2 class="text-2xl font-semibold mb-4 text-gold-100">
            <i class="fas fa-book-open text-gold-500 mr-2"></i> Crypto Probo Prediction Cheat Sheet Reference
        </h2>
        <p class="text-gold-400 mb-4">This section provides the original guidelines for reference, updated with new indicators.</p>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">‚úÖ TRUST the Prediction When:</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-2 mb-4">
            <li><strong>Time to expiry is &lt; 2 hours</strong>: Short-term moves are easier to project with recent trend/sentiment.</li>
            <li><strong>[Currency] is trending cleanly (up or down)</strong>: EMA crossover + delta will align clearly; MACD bearish crossover is absent.</li>
            <li><strong>Sentiment score is strongly positive/negative (&gt;0.2)</strong>: Clear market direction from sentiment.</li>
            <li><strong>RSI is not extreme (30‚Äì70)</strong>: Means no strong mean-reversion counterforces.</li>
            <li><strong>No major news expected</strong>: Market moves more "technically" in news-free windows; sentiment score > 0.05.</li>
            <li><strong>Candle bodies are stable (not huge wicks)</strong>: Less noise = better delta prediction accuracy. Candle volatility is low.</li>
            <li><strong>MACD shows bullish crossover</strong>: Indicates strengthening upward momentum; MACD line > Signal line and Histogram > 0.</li>
            <li><strong>Stochastic is oversold (potential rebound)</strong>: Price may be due for an upward correction; %K &lt; 20, %D &lt; 20, and %K > %D.</li>
            <li><strong>Price near lower Bollinger Band (potential support)</strong>: Suggests price is at a strong support level.</li>
            <li><strong>No massive move recently</strong>: Predictable price action.</li>
            <li><strong>Bollinger Bands are stable (not squeezing/expanding)</strong>: Less volatility uncertainty.</li>
            <li><strong>No recent volume spike</strong>: Market not reacting to sudden news/events.</li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">‚ö†Ô∏è BE CAUTIOUS / DOUBLE-CHECK When:</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-2 mb-4">
            <li><strong>Target time is &gt; 3 hours away</strong>: Market conditions may shift unpredictably.</li>
            <li><strong>[Currency] just made a massive move</strong>: Mean reversion likely ‚Üí momentum may reverse.</li>
            <li><strong>RSI is &gt; 70 or &lt; 30 (extreme)</strong>: Overbought/oversold zones are prone to reversals.</li>
            <li><strong>Sentiment is conflicting (score ‚âà 0)</strong>: Market indecisive ‚Äî avoid betting.</li>
            <li><strong>Market Volatility due to News/Events (sentiment conflicting OR volume spike)</strong>: Trends and sentiment can break instantly due to external factors or sudden interest.</li>
            <li><strong>Candle volatility is high (huge wicks)</strong>: Delta estimates become noisy and inaccurate.</li>
            <li><strong>MACD shows bearish crossover</strong>: Indicates strengthening downward momentum; MACD line &lt; Signal line and Histogram &lt; 0.</li>
            <li><strong>Stochastic is overbought (potential reversal)</strong>: Price may be due for a downward correction; %K &gt; 80, %D &gt; 80, and %K &lt; %D.</li>
            <li><strong>Price near upper Bollinger Band or BB contracting</strong>: Suggests strong resistance or potential for volatile breakout.</li>
            <li><strong>Bollinger Bands are volatile (squeezing/expanding)</strong>: High uncertainty, potential for sharp moves.</li>
            <li><strong>Recent volume spike</strong>: Market reacting to sudden news/events, unpredictable.</li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">üîê Pro Tip (Original Reference):</h3>
        <p class="text-gold-300 mb-2">If at least 7/12 ‚ÄúTrust‚Äù signals align AND less than 4 ‚ÄúCaution‚Äù flags are present ‚Üí GO with the vote.</p>
        <p class="text-gold-300 mb-4">If 4+ ‚ÄúCaution‚Äù flags are present ‚Üí SKIP the trade or wait.</p>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">‚úÖ Example: When to TRUST (Original Reference)</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li>Time: 1 hour left</li>
            <li>BTC uptrending (EMA20 &gt; EMA50, no bearish MACD cross)</li>
            <li>RSI = 58 (Neutral)</li>
            <li>Sentiment = +0.3 (Strong positive)</li>
            <li>MACD bullish crossover</li>
            <li>Stochastic not extreme (e.g., 40, 35)</li>
            <li>Price not near BB extremes (e.g., mid-band)</li>
            <li>No massive move recently</li>
            <li>BB stable</li>
            <li>No recent volume spike</li>
            <li>‚Üí ‚úÖ Trust YES vote</li>
        </ul>

        <h3 class="text-xl font-semibold text-gold-100 mb-2">‚ö†Ô∏è Example: When to AVOID (Original Reference)</h3>
        <ul class="list-disc list-inside text-gold-300 space-y-1 mb-4">
            <li>Time: 4 hours left</li>
            <li>BTC dumped $800 in 15 mins (Massive move)</li>
            <li>RSI = 22 (Oversold)</li>
            <li>Sentiment = 0.05 (Conflicting)</li>
            <li>MACD bearish crossover</li>
            <li>Stochastic overbought (e.g., 90, 85)</li>
            <li>Price near upper BB</li>
            <li>BB squeezing</li>
            <li>Recent volume spike</li>
            <li>‚Üí ‚ö†Ô∏è Avoid vote ‚Äî unpredictable zone</li>
        </ul>

    </div>

    <script>
        // Helper function to toggle expander sections
        function setupExpander(headerId, contentId) {
            const header = document.getElementById(headerId);
            const content = document.getElementById(contentId);
            const arrow = header ? header.querySelector('.arrow') : null;

            if (!header || !content || !arrow) { // Robustness check
                // console.warn(`Expander setup failed for ${headerId}. Element not found.`);
                return;
            }

            header.addEventListener('click', () => {
                const isExpanded = content.classList.contains('expanded');
                if (isExpanded) {
                    content.classList.remove('expanded');
                    arrow.classList.remove('expanded');
                } else {
                    content.classList.add('expanded');
                    arrow.classList.add('expanded');
                }
            });
        }

        // --- Backend API URL ---
        const BACKEND_API_URL = 'http://localhost:5000'; // Use this for local development!
        // const BACKEND_API_URL = 'https://html-probo-predictor-website.onrender.com'; // IMPORTANT: Change this for deployment!

        // Global data storage for both BTC and ETH
        let allMarketData = {
            BTC: { current_price: 0.0, sentiment_score: 0.0, market_conditions: {}, chart_data: [] },
            ETH: { current_price: 0.0, sentiment_score: 0.0, market_conditions: {}, chart_data: [] }
        };
        let selectedCurrency = 'BTC'; // Default selected currency

        // --- UI Update Functions ---

        function updateConfidenceSignal(elementId, isTrue) {
            const element = document.getElementById(elementId);
            const iconId = elementId + '-icon';
            const iconElement = document.getElementById(iconId);

            if (!element) return; // Guard against missing elements

            if (isTrue) {
                element.innerHTML = '<strong class="text-green-400">YES</strong>';
                if (iconElement) iconElement.innerHTML = '<i class="fas fa-check-circle check-icon mr-2"></i>';
            } else {
                element.innerHTML = '<strong class="text-red-400">NO</strong>';
                if (iconElement) iconElement.innerHTML = '<i class="fas fa-times-circle cross-icon mr-2"></i>';
            }
        }

        // Global variable to keep track of chart instances
        let plotlyChartInstance = null;

        function updateUI(currencyData, predictionResult = null, geminiAiResult = null) {
            const { current_price, sentiment_score, market_conditions, chart_data } = currencyData;

            // Update currency symbol display
            document.getElementById('current-currency-symbol').textContent = selectedCurrency;

            // Update Current Price Metric
            document.getElementById('current-price-display').textContent = `$${current_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

            // Update Technical Indicators
            document.getElementById('metric-rsi').textContent = market_conditions.rsi !== null ? market_conditions.rsi.toFixed(2) : 'N/A';
            document.getElementById('metric-ema20').textContent = market_conditions.ema_20 !== null ? market_conditions.ema_20.toFixed(2) : 'N/A';
            document.getElementById('metric-ema50').textContent = market_conditions.ema_50 !== null ? market_conditions.ema_50.toFixed(2) : 'N/A';
            document.getElementById('metric-macd').textContent = market_conditions.macd !== null ? market_conditions.macd.toFixed(2) : 'N/A';
            document.getElementById('metric-stochk').textContent = market_conditions.stoch_k !== null ? market_conditions.stoch_k.toFixed(2) : 'N/A';
            document.getElementById('metric-stochd').textContent = market_conditions.stoch_d !== null ? market_conditions.stoch_d.toFixed(2) : 'N/A';

            const bbUpper = market_conditions.bb_upper !== null ? market_conditions.bb_upper.toFixed(2) : 'N/A';
            const bbMid = market_conditions.bb_mid !== null ? market_conditions.bb_mid.toFixed(2) : 'N/A';
            const bbLower = market_conditions.bb_lower !== null ? market_conditions.bb_lower.toFixed(2) : 'N/A';
            document.getElementById('metric-bb').textContent = `${bbUpper} / ${bbMid} / ${bbLower}`;
            document.getElementById('metric-bb-width').textContent = market_conditions.bb_width !== null ? market_conditions.bb_width.toFixed(2) : 'N/A';


            document.getElementById('market-trend').textContent = market_conditions.bullish_trend ? 'üìà Uptrend (EMA20 > EMA50)' : 'üìâ Downtrend (EMA20 < EMA50)';
            let rsiZone = '';
            if (market_conditions.overbought) rsiZone = 'üî• Overbought (>70)';
            else if (market_conditions.oversold) rsiZone = 'üßä Oversold (<30)';
            else rsiZone = '‚úÖ Neutral (30-70)';
            document.getElementById('market-rsi-zone').textContent = rsiZone;

            let stochZone = '';
            if (market_conditions.stoch_overbought) stochZone = 'üî• Overbought (>80)';
            else if (market_conditions.stoch_oversold) stochZone = 'üßä Oversold (<20)';
            else stochZone = '‚úÖ Neutral (20-80)';
            document.getElementById('market-stoch-zone').textContent = stochZone;

            // Update Chart
            drawChart(chart_data);

            // Update Prophet Prediction Summary and Confidence Advisor if predictionResult is available
            if (predictionResult) {
                document.getElementById('summary-current-price').textContent = `$${predictionResult.current_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-avg-delta').textContent = `$${predictionResult.avg_delta_per_hour.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-time-left').textContent = `${predictionResult.hours_remaining} hr(s)`;
                document.getElementById('summary-projected-price').textContent = `$${predictionResult.projected_price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                document.getElementById('summary-sentiment-score').textContent = predictionResult.sentiment.toFixed(2);
                document.getElementById('summary-target-time').textContent = predictionResult.target_time_ist; // Use IST string here

                const voteMessageDiv = document.getElementById('recommended-vote-message');
                if (predictionResult.vote === "YES") {
                    voteMessageDiv.className = 'success-message text-center text-xl font-bold py-3 px-4 rounded-lg';
                    voteMessageDiv.innerHTML = `üß† Prophet Recommended Vote: <strong class="text-green-400">YES</strong>`;
                } else {
                    voteMessageDiv.className = 'warning-message text-center text-xl font-bold py-3 px-4 rounded-lg';
                    voteMessageDiv.innerHTML = `üß† Prophet Recommended Vote: <strong class="text-red-400">NO</strong>`;
                }
                voteMessageDiv.classList.remove('hidden');

                const confidence = predictionResult.confidence_advisor;

                // Update Trust Signals
                document.getElementById('trust-currency-name').textContent = selectedCurrency;
                updateConfidenceSignal('trust-time', confidence.trust_conditions.time_expiry_lt_2hr);
                updateConfidenceSignal('trust-trend', confidence.trust_conditions.trending_cleanly);
                updateConfidenceSignal('trust-sentiment', confidence.trust_conditions.sentiment_strong);
                document.getElementById('trust-sentiment').innerHTML += ` (Score: ${sentiment_score.toFixed(2)})`; // Add score for context
                updateConfidenceSignal('trust-rsi', confidence.trust_conditions.rsi_neutral);
                document.getElementById('trust-rsi').innerHTML += ` (RSI: ${market_conditions.rsi !== null ? market_conditions.rsi.toFixed(2) : 'N/A'})`; // Add RSI for context
                updateConfidenceSignal('trust-news', confidence.trust_conditions.no_major_news_expected);
                updateConfidenceSignal('trust-stable-candles', confidence.trust_conditions.candle_bodies_stable_not_volatile);
                updateConfidenceSignal('trust-macd-bullish', confidence.trust_conditions.macd_bullish_crossover_confirmed);
                updateConfidenceSignal('trust-stoch-oversold', confidence.trust_conditions.stoch_oversold_bullish_cross);
                updateConfidenceSignal('trust-bb-lower', confidence.trust_conditions.price_near_bb_lower);
                updateConfidenceSignal('trust-no-massive-move', confidence.trust_conditions.no_massive_move_recent);
                updateConfidenceSignal('trust-bb-stable', confidence.trust_conditions.bb_stable);
                updateConfidenceSignal('trust-no-volume-spike', confidence.trust_conditions.no_volume_spike_recent);


                // Update Caution Flags
                document.getElementById('caution-currency-name').textContent = selectedCurrency;
                updateConfidenceSignal('caution-time', confidence.caution_conditions.target_time_gt_3hr);
                updateConfidenceSignal('caution-massive-move', confidence.caution_conditions.btc_massive_move);
                updateConfidenceSignal('caution-rsi', confidence.caution_conditions.rsi_extreme);
                document.getElementById('caution-rsi').innerHTML += ` (RSI: ${market_conditions.rsi !== null ? market_conditions.rsi.toFixed(2) : 'N/A'})`; // Add RSI for context
                updateConfidenceSignal('caution-sentiment', confidence.caution_conditions.sentiment_conflicting);
                document.getElementById('caution-sentiment').innerHTML += ` (Score: ${sentiment_score.toFixed(2)})`; // Add score for context
                updateConfidenceSignal('caution-big-news', confidence.caution_conditions.big_news_coming_or_volume_spike);
                updateConfidenceSignal('caution-volatile-candles', confidence.caution_conditions.candle_volatility_high);
                updateConfidenceSignal('caution-macd-bearish', confidence.caution_conditions.macd_bearish_crossover_confirmed);
                updateConfidenceSignal('caution-stoch-overbought', confidence.caution_conditions.stoch_overbought_bearish_cross);
                updateConfidenceSignal('caution-bb-upper-contracting', confidence.caution_conditions.price_near_bb_upper_or_bb_volatile); // Adjusted to match backend key
                updateConfidenceSignal('caution-bb-volatile', confidence.caution_conditions.bb_volatile);
                updateConfidenceSignal('caution-volume-spike', confidence.caution_conditions.volume_spike_recent);


                document.getElementById('total-trust-signals').textContent = confidence.trust_signals_count;
                document.getElementById('total-caution-flags').textContent = confidence.caution_flags_count;

                const proTipMessageDiv = document.getElementById('pro-tip-message');
                let proTipClass = '';
                let adviceMessage = confidence.advice_message;

                if (confidence.trust_signals_count >= 7 && confidence.caution_flags_count < 4) {
                    proTipClass = 'success-message';
                } else if (confidence.caution_flags_count >= 4) {
                    proTipClass = 'warning-message';
                } else {
                    proTipClass = 'info-message';
                }
                proTipMessageDiv.innerHTML = `<div class="${proTipClass}"><strong class="text-lg">${adviceMessage}</strong><p class="text-sm mt-1">Trust: ${confidence.trust_signals_count}/12, Caution: ${confidence.caution_flags_count}/11</p></div>`;
            } else {
                // Clear prediction results if no prediction is active
                document.getElementById('recommended-vote-message').classList.add('hidden');
                document.getElementById('pro-tip-message').innerHTML = '';

                // Reset confidence advisor status to N/A
                const trustElements = [
                    'trust-time', 'trust-trend', 'trust-sentiment', 'trust-rsi', 'trust-news',
                    'trust-stable-candles', 'trust-macd-bullish', 'trust-stoch-oversold',
                    'trust-bb-lower', 'trust-no-massive-move', 'trust-bb-stable', 'trust-no-volume-spike'
                ];
                const cautionElements = [
                    'caution-time', 'caution-massive-move', 'caution-rsi', 'caution-sentiment',
                    'caution-big-news', 'caution-volatile-candles', 'caution-macd-bearish',
                    'caution-stoch-overbought', 'caution-bb-upper-contracting',
                    'caution-bb-volatile', 'caution-volume-spike'
                ];

                trustElements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = 'N/A';
                    const iconElement = document.getElementById(id + '-icon');
                    if (iconElement) iconElement.innerHTML = '<i class="fas fa-question-circle text-gray-500 mr-2"></i>';
                });
                cautionElements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = 'N/A';
                    const iconElement = document.getElementById(id + '-icon');
                    if (iconElement) iconElement.innerHTML = '<i class="fas fa-question-circle text-gray-500 mr-2"></i>';
                });

                document.getElementById('total-trust-signals').textContent = '0';
                document.getElementById('total-caution-flags').textContent = '0';

                document.getElementById('trust-currency-name').textContent = selectedCurrency;
                document.getElementById('caution-currency-name').textContent = selectedCurrency;
            }

            // Update Gemini AI Vote Section
            const geminiAiVoteElem = document.getElementById('gemini-ai-vote');
            const geminiAiReasoningElem = document.getElementById('gemini-ai-reasoning');
            if (geminiAiResult) {
                if (geminiAiResult.ai_vote === "YES") {
                    geminiAiVoteElem.innerHTML = `<strong class="text-green-400">YES</strong>`;
                } else if (geminiAiResult.ai_vote === "NO") {
                    geminiAiVoteElem.innerHTML = `<strong class="text-red-400">NO</strong>`;
                } else {
                    geminiAiVoteElem.innerHTML = `<strong class="text-gray-400">N/A</strong>`;
                }
                geminiAiReasoningElem.textContent = geminiAiResult.ai_reasoning;
            } else {
                geminiAiVoteElem.innerHTML = `<strong class="text-gray-400">N/A</strong>`;
                geminiAiReasoningElem.textContent = 'Awaiting prediction...';
            }
        }

        // --- Charting with Plotly.js ---

        function drawChart(chartData) {
            if (!Array.isArray(chartData) || chartData.length === 0) {
                console.warn("No chart data available to draw.");
                Plotly.purge('candlestick-chart');
                plotlyChartInstance = null; // Clear instance if no data
                return;
            }

            const timestamps = chartData.map(d => d.timestamp);
            const openPrices = chartData.map(d => d.open);
            const highPrices = chartData.map(d => d.high);
            const lowPrices = chartData.map(d => d.low);
            const closePrices = chartData.map(d => d.close);
            const volume = chartData.map(d => d.volume);
            const ema20 = chartData.map(d => d.EMA_20);
            const ema50 = chartData.map(d => d.EMA_50);
            const bbUpper = chartData.map(d => d.BB_Upper);
            const bbLower = chartData.map(d => d.BB_Lower);
            const bbMid = chartData.map(d => d.BB_Mid);
            const macd = chartData.map(d => d.MACD);
            const macdSignal = chartData.map(d => d.MACD_Signal);
            const macdHist = chartData.map(d => d.MACD_Hist);
            const stochK = chartData.map(d => d.STOCH_K);
            const stochD = chartData.map(d => d.STOCH_D);

            // Define traces
            const traces = [];

            // Candlestick trace (main price chart)
            traces.push({
                x: timestamps,
                open: openPrices,
                high: highPrices,
                low: lowPrices,
                close: closePrices,
                type: 'candlestick',
                name: 'Candles',
                increasing: { line: { color: '#FFD700' } }, /* Gold for increasing */
                decreasing: { line: { color: '#B22222' } }, /* Firebrick for decreasing */
                xaxis: 'x',
                yaxis: 'y'
            });

            // EMA 20
            traces.push({
                x: timestamps,
                y: ema20,
                type: 'scatter',
                mode: 'lines',
                name: 'EMA 20',
                line: { color: '#87CEEB', width: 1.5 }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // EMA 50
            traces.push({
                x: timestamps,
                y: ema50,
                type: 'scatter',
                mode: 'lines',
                name: 'EMA 50',
                line: { color: '#DAA520', width: 1.5 }, /* Goldenrod */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // BB Mid
            traces.push({
                x: timestamps,
                y: bbMid,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Mid',
                line: { color: '#A9A9A9', width: 1, dash: 'dash' }, /* DarkGrey */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });
            // BB Upper
            traces.push({
                x: timestamps,
                y: bbUpper,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Upper',
                line: { color: '#6A5ACD', width: 1 }, /* SlateBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });
            // BB Lower
            traces.push({
                x: timestamps,
                y: bbLower,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Lower',
                line: { color: '#6A5ACD', width: 1 }, /* SlateBlue */
                showlegend: true,
                xaxis: 'x',
                yaxis: 'y'
            });

            // Volume
            traces.push({
                x: timestamps,
                y: volume,
                type: 'bar',
                name: 'Volume',
                marker: { color: '#444444' }, /* Darker grey for volume bars */
                showlegend: false,
                xaxis: 'x2',
                yaxis: 'y2'
            });

            // MACD Line
            traces.push({
                x: timestamps,
                y: macd,
                type: 'scatter',
                mode: 'lines',
                name: 'MACD',
                line: { color: '#FFD700', width: 1.5 }, /* Gold */
                showlegend: true,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // MACD Signal Line
            traces.push({
                x: timestamps,
                y: macdSignal,
                type: 'scatter',
                mode: 'lines',
                name: 'Signal',
                line: { color: '#87CEEB', width: 1.5, dash: 'dot' }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // MACD Histogram
            traces.push({
                x: timestamps,
                y: macdHist,
                type: 'bar',
                name: 'Histogram',
                marker: {
                    color: macdHist.map(val => val >= 0 ? '#9ae6b4' : '#feb2b2') /* Green for positive, Red for negative */
                },
                showlegend: false,
                xaxis: 'x3',
                yaxis: 'y3'
            });

            // Stochastic %K
            traces.push({
                x: timestamps,
                y: stochK,
                type: 'scatter',
                mode: 'lines',
                name: '%K',
                line: { color: '#FFD700', width: 1.5 }, /* Gold */
                showlegend: true,
                xaxis: 'x4',
                yaxis: 'y4'
            });

            // Stochastic %D
            traces.push({
                x: timestamps,
                y: stochD,
                type: 'scatter',
                mode: 'lines',
                name: '%D',
                line: { color: '#87CEEB', width: 1.5, dash: 'dot' }, /* SkyBlue */
                showlegend: true,
                xaxis: 'x4',
                yaxis: 'y4'
            });

            // Define layout with multiple axes
            const layout = {
                grid: {
                    rows: 4,
                    columns: 1,
                    pattern: 'independent',
                    rowheights: [0.5, 0.2, 0.15, 0.15],
                    subplots: [['xy'], ['xy2'], ['xy3'], ['xy4']] // Map traces to subplots
                },
                xaxis: {
                    rangeslider: { visible: false },
                    type: 'date',
                    title: 'Time',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis2: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis3: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                xaxis4: {
                    rangeslider: { visible: false },
                    type: 'date',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444',
                    range: [0, 100] /* Stochastic is always 0-100 */
                },
                yaxis: {
                    title: 'Price (USDT)',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis2: {
                    title: 'Volume',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis3: {
                    title: 'MACD',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444'
                },
                yaxis4: {
                    title: 'Stochastic',
                    tickfont: { color: '#DAA520' },
                    gridcolor: '#333333',
                    linecolor: '#444444',
                    range: [0, 100] /* Stochastic is always 0-100 */
                },
                plot_bgcolor: '#222222',
                paper_bgcolor: '#222222',
                font: { color: '#FFD700' },
                margin: { l: 40, r: 40, t: 30, b: 30 },
                showlegend: true,
                legend: {
                    x: 0, y: 1.15,
                    bgcolor: 'rgba(0,0,0,0)',
                    bordercolor: 'rgba(0,0,0,0)',
                    font: { color: '#FFD700' }
                }
            };

            if (plotlyChartInstance) {
                // If chart exists, update it with new data
                Plotly.react('candlestick-chart', traces, layout, { responsive: true, displayModeBar: true });
            } else {
                // Otherwise, create a new chart
                Plotly.newPlot('candlestick-chart', traces, layout, { responsive: true, displayModeBar: true })
                    .then(gd => {
                        plotlyChartInstance = gd; // Store the chart instance
                    })
                    .catch(error => {
                        console.error("Error creating Plotly chart:", error);
                        Plotly.purge('candlestick-chart');
                        plotlyChartInstance = null;
                        document.getElementById('candlestick-chart').innerHTML = '<div class="error-message text-center p-4">‚ùå Failed to load chart. Check console for details.</div>';
                    });
            }
        }

        // --- Main Application Logic ---

        function showLoading(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.classList.remove('hidden');
        }

        function hideLoading(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.classList.add('hidden');
        }

        function updateCurrentISTTime() {
            const now = new Date();
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'Asia/Kolkata'
            };
            const timeElement = document.getElementById('current-ist-time');
            if (timeElement) timeElement.textContent = now.toLocaleTimeString('en-IN', options);
        }

        async function initializeApp() {
            showLoading('loading-spinner');
            const priceDisplay = document.getElementById('current-price-display');
            if (priceDisplay) priceDisplay.textContent = "Loading...";

            const messageDiv = document.getElementById('recommended-vote-message');
            if (messageDiv) {
                messageDiv.innerHTML = '';
                messageDiv.classList.add('hidden');
            }
            const proTipMessage = document.getElementById('pro-tip-message');
            if (proTipMessage) proTipMessage.innerHTML = '';

            try {
                const response = await fetch(`${BACKEND_API_URL}/api/market_data`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`HTTP error! status: ${response.status} - ${errorData.error || response.statusText}`);
                }
                allMarketData = await response.json();

                // Update UI with data for the currently selected currency, clear previous predictions
                updateUI(allMarketData[selectedCurrency], null, null);

            } catch (error) {
                console.error("Error fetching market data:", error);
                const messageDiv = document.getElementById('recommended-vote-message');
                if (messageDiv) {
                    messageDiv.innerHTML = `<div class="error-message">‚ùå Failed to load market data. Please ensure the backend server is running and accessible at ${BACKEND_API_URL}. Error: ${error.message}</div>`;
                    messageDiv.classList.remove('hidden');
                }
                if (priceDisplay) priceDisplay.textContent = "$ERROR";
            } finally {
                hideLoading('loading-spinner');
            }
        }

        // Handle form submission
        document.getElementById('prediction-form').addEventListener('submit', async (event) => {
            event.preventDefault();

            showLoading('prediction-spinner');
            showLoading('gemini-vote-spinner');
            const geminiAiVoteElem = document.getElementById('gemini-ai-vote');
            const geminiAiReasoningElem = document.getElementById('gemini-ai-reasoning');
            if(geminiAiVoteElem) geminiAiVoteElem.innerHTML = 'Loading...';
            if(geminiAiReasoningElem) geminiAiReasoningElem.textContent = 'Generating AI analysis...';

            const targetPrice = parseFloat(document.getElementById('target-price').value);
            const targetTimeStr = document.getElementById('target-time').value;
            const selectedCurrencyForPrediction = document.querySelector('input[name="currency"]:checked').value;

            const messageDiv = document.getElementById('recommended-vote-message');
            if (messageDiv) {
                messageDiv.innerHTML = '';
                messageDiv.classList.add('hidden');
            }
            const proTipMessage = document.getElementById('pro-tip-message');
            if (proTipMessage) proTipMessage.innerHTML = '';


            if (isNaN(targetPrice) || !targetTimeStr) {
                if (messageDiv) {
                    messageDiv.innerHTML = `<div class="error-message">‚ùå Please enter a valid target price and time.</div>`;
                    messageDiv.classList.remove('hidden');
                }
                hideLoading('prediction-spinner');
                hideLoading('gemini-vote-spinner');
                if(geminiAiVoteElem) geminiAiVoteElem.innerHTML = 'N/A';
                if(geminiAiReasoningElem) geminiAiReasoningElem.textContent = 'Invalid input for prediction.';
                return;
            }

            let prophetPredictionResult = null;
            let geminiAiPredictionResult = null;

            try {
                // 1. Get Prophet Prediction
                const prophetResponse = await fetch(`${BACKEND_API_URL}/api/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        target_price: targetPrice,
                        target_time: targetTimeStr,
                        currency: selectedCurrencyForPrediction
                    })
                });

                if (!prophetResponse.ok) {
                    const errorData = await prophetResponse.json();
                    throw new Error(`Prophet prediction failed: ${errorData.error || prophetResponse.statusText}`);
                }
                prophetPredictionResult = await prophetResponse.json();

                // 2. Get Gemini AI Prediction
                const geminiAiResponse = await fetch(`${BACKEND_API_URL}/api/gemini_ai_vote`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        target_price: targetPrice,
                        target_time: targetTimeStr,
                        currency: selectedCurrencyForPrediction
                    })
                });

                if (!geminiAiResponse.ok) {
                    const errorData = await geminiAiResponse.json();
                    throw new Error(`Gemini AI prediction failed: ${errorData.error || geminiAiResponse.statusText}`);
                }
                geminiAiPredictionResult = await geminiAiResponse.json();


                // 3. Re-fetch all market data to ensure the UI is consistent with the latest backend state
                const marketDataResponse = await fetch(`${BACKEND_API_URL}/api/market_data`);
                if (!marketDataResponse.ok) {
                    const errorData = await marketDataResponse.json();
                    throw new Error(`Failed to refresh market data after prediction: ${errorData.error || marketDataResponse.statusText}`);
                }
                allMarketData = await marketDataResponse.json();

                // Update UI with both prediction results for the *selected* currency
                updateUI(allMarketData[selectedCurrency], prophetPredictionResult, geminiAiPredictionResult);

            } catch (error) {
                console.error("Error during prediction:", error);
                if (messageDiv) {
                    messageDiv.innerHTML = `<div class="error-message">‚ùå ${error.message}</div>`;
                    messageDiv.classList.remove('hidden');
                }
                if(geminiAiVoteElem) geminiAiVoteElem.innerHTML = 'ERROR';
                if(geminiAiReasoningElem) geminiAiReasoningElem.textContent = `Failed to get AI prediction: ${error.message}`;
            } finally {
                hideLoading('prediction-spinner');
                hideLoading('gemini-vote-spinner');
            }
        });

        // Handle currency selection change
        document.querySelectorAll('input[name="currency"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                selectedCurrency = event.target.value;
                // Update UI immediately with the newly selected currency's data, clearing old prediction results
                updateUI(allMarketData[selectedCurrency], null, null);
            });
        });

        // --- Chart resize on expand handler (NEW) ---
        function setupExpanderWithPlotly(headerId, contentId, plotlyDivId) {
            const header = document.getElementById(headerId);
            const content = document.getElementById(contentId);
            const arrow = header ? header.querySelector('.arrow') : null;

            if (!header || !content || !arrow) return;

            header.addEventListener('click', () => {
                content.classList.toggle('expanded');
                arrow.classList.toggle('expanded');
                // If content is now expanded, trigger Plotly resize
                if (content.classList.contains('expanded') && plotlyChartInstance && plotlyDivId) {
                    setTimeout(() => Plotly.relayout(plotlyDivId, {autosize: true}), 500); // Allow animation to finish
                }
            });
        }

        // --- Chatbot Logic ---
        const chatWindow = document.getElementById('chat-window'); // This is inside the potentially floating div
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatSpinner = document.getElementById('chat-spinner');
        const chatFileInput = document.getElementById('chat-file-input');
        const uploadedFilesPreview = document.getElementById('uploaded-files-preview');
        const chatErrorMessage = document.getElementById('chat-error-message');

        let attachedFiles = [];

        function addMessageToChat(sender, message, files = []) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', sender);

            const bubble = document.createElement('div');
            bubble.classList.add('chat-bubble', sender);
            bubble.textContent = message;
            messageDiv.appendChild(bubble);

            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.classList.add('chat-file-preview');
                    messageDiv.appendChild(img);
                } else {
                    const fileText = document.createElement('p');
                    fileText.classList.add('text-sm', 'text-gray-400', 'mt-1');
                    fileText.textContent = `Attached: ${file.name}`;
                    messageDiv.appendChild(fileText);
                }
            });

            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // Auto-scroll to bottom
        }

        async function sendChatMessage() {
            const message = chatInput.value.trim();
            chatErrorMessage.classList.add('hidden');

            if (!message && attachedFiles.length === 0) {
                chatErrorMessage.textContent = 'Please enter a message or select a file.';
                chatErrorMessage.classList.remove('hidden');
                return;
            }

            addMessageToChat('user', message, attachedFiles);
            chatInput.value = ''; // Clear input
            uploadedFilesPreview.innerHTML = ''; // Clear file previews

            showLoading('chat-spinner');

            try {
                const formData = new FormData();
                if (message) {
                    formData.append('message', message);
                }
                attachedFiles.forEach((file) => {
                    formData.append('files', file);
                });

                const response = await fetch(`${BACKEND_API_URL}/api/ai_chat`, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Chatbot error: ${errorData.error || response.statusText}`);
                }

                const result = await response.json();
                addMessageToChat('ai', result.ai_response);

            } catch (error) {
                console.error("Error sending chat message:", error);
                chatErrorMessage.textContent = `‚ùå ${error.message}`;
                chatErrorMessage.classList.remove('hidden');
                addMessageToChat('ai', `Sorry, I encountered an error: ${error.message}`);
            } finally {
                hideLoading('chat-spinner');
                attachedFiles = []; // Reset attached files after sending
                chatFileInput.value = ''; // Clear file input element itself
            }
        }

        sendChatBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent new line in textarea
                sendChatMessage();
            }
        });

        chatFileInput.addEventListener('change', (event) => {
            uploadedFilesPreview.innerHTML = ''; // Clear previous previews
            attachedFiles = Array.from(event.target.files);

            attachedFiles.forEach((file, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('flex', 'justify-between', 'items-center', 'text-gold-300');
                listItem.innerHTML = `
                    <span><i class="fas fa-file mr-2"></i>${file.name}</span>
                    <i class="fas fa-times-circle remove-file cursor-pointer" data-index="${index}"></i>
                `;
                uploadedFilesPreview.appendChild(listItem);
            });

            // Add event listeners for removing files
            uploadedFilesPreview.querySelectorAll('.remove-file').forEach(button => {
                button.addEventListener('click', (e) => {
                    const indexToRemove = parseInt(e.target.dataset.index);
                    attachedFiles.splice(indexToRemove, 1); // Remove from array
                    e.target.closest('li').remove(); // Remove from UI
                    // If no files are left, clear the actual file input element
                    if (attachedFiles.length === 0) {
                        chatFileInput.value = '';
                    } else {
                        // Re-render the list to update indices
                        const tempFiles = Array.from(attachedFiles); // Copy to re-render
                        attachedFiles = []; // Clear for re-population
                        chatFileInput.files = null; // Clear native input
                        // Manually trigger the change event with new files (tricky for FileList)
                        // A simpler approach is just to update the preview list.
                        const dataTransfer = new DataTransfer();
                        tempFiles.forEach(file => dataTransfer.items.add(file));
                        chatFileInput.files = dataTransfer.files;
                        chatFileInput.dispatchEvent(new Event('change')); // Trigger re-render of preview
                    }
                });
            });
        });


        // Initialize the app when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            updateCurrentISTTime(); // Set initial time
            setInterval(updateCurrentISTTime, 1000); // Update time every second

            // Setup all expanders. Chart expander now explicitly handles Plotly resize.
            setupExpander('prediction-summary-expander', 'prediction-summary-content');
            setupExpander('technical-indicators-expander', 'technical-indicators-content');
            setupExpanderWithPlotly('chart-expander', 'chart-content', 'candlestick-chart'); // Specific setup for chart
            setupExpander('trust-signals-expander', 'trust-signals-content');
            setupExpander('caution-flags-expander', 'caution-flags-content');
            setupExpander('gemini-ai-vote-expander', 'gemini-ai-vote-content');

            // Initialize chart on page load (it's expanded by default now)
            // This call will be redundant after initialApp() is done, but safe.
            // The actual data will be loaded by initializeApp.
            // drawChart(allMarketData[selectedCurrency].chart_data); // Removed - initializeApp handles this now.
        });

        // Periodically update market data (e.g., every 1 minute for a more "real-time" feel)
        setInterval(initializeApp, 60000); // 60000 ms = 1 minute

        // --- Floating Chatbot UI/Logic (NEW) ---
        const floatingChatbotContainer = document.createElement('div');
        floatingChatbotContainer.id = 'floating-chatbot-container';
        floatingChatbotContainer.className = 'fixed bottom-4 right-4 z-50 flex flex-col items-end';
        document.body.appendChild(floatingChatbotContainer);

        const chatToggleBtn = document.createElement('button');
        chatToggleBtn.id = 'chat-toggle-btn';
        chatToggleBtn.innerHTML = '<i class="fas fa-comment"></i>'; // Initial icon
        floatingChatbotContainer.appendChild(chatToggleBtn);

        // Get the static chatbot section, then move its content
        const staticChatbotSection = document.getElementById('static-ai-chatbot-section');
        const chatbotContentMoved = staticChatbotSection.querySelector('#ai-chatbot-content');
        const chatbotHeaderMoved = staticChatbotSection.querySelector('#ai-chatbot-expander');

        // Hide the original static chatbot section from the main document flow
        staticChatbotSection.style.display = 'none';

        // Create a new container for the actual chatbot window that will be toggled
        const floatingChatWindow = document.createElement('div');
        floatingChatWindow.id = 'floating-chat-window-content';
        floatingChatWindow.className = 'w-96 bg-gray-900 rounded-lg shadow-xl overflow-hidden transform scale-0 origin-bottom-right transition-all duration-300 ease-in-out hidden'; // Initially hidden and scaled down

        floatingChatWindow.appendChild(chatbotHeaderMoved); // Move header to floating
        floatingChatWindow.appendChild(chatbotContentMoved); // Move content to floating
        floatingChatbotContainer.appendChild(floatingChatWindow);

        let isChatOpen = false;

        chatToggleBtn.addEventListener('click', () => {
            isChatOpen = !isChatOpen;
            if (isChatOpen) {
                floatingChatWindow.classList.remove('hidden');
                floatingChatWindow.classList.remove('scale-0');
                floatingChatWindow.classList.add('scale-100');
                chatToggleBtn.innerHTML = '<i class="fas fa-times"></i>'; // Change icon to 'X'
                // Expand the content inside the floating window if it's not already
                if (!chatbotContentMoved.classList.contains('expanded')) {
                    chatbotContentMoved.classList.add('expanded');
                    chatbotHeaderMoved.querySelector('.arrow').classList.add('expanded');
                }
                if (chatWindow) chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom on open
            } else {
                floatingChatWindow.classList.remove('scale-100');
                floatingChatWindow.classList.add('scale-0');
                // Use a transitionend event to hide the element completely after the animation
                floatingChatWindow.addEventListener('transitionend', function handler() {
                    if (!isChatOpen) { // Only hide after transition if still closed
                        floatingChatWindow.classList.add('hidden');
                    }
                    floatingChatWindow.removeEventListener('transitionend', handler);
                });
                chatToggleBtn.innerHTML = '<i class="fas fa-comment"></i>'; // Change icon back to comment
            }
        });

        // Re-setup the chatbot content as an expander *within* the floating window
        // but ensure it's initially expanded when the floating window is shown.
        document.addEventListener('DOMContentLoaded', () => {
            const floatingChatbotContent = document.getElementById('ai-chatbot-content');
            const floatingChatbotHeader = document.getElementById('ai-chatbot-expander');
            const floatingChatbotArrow = floatingChatbotHeader ? floatingChatbotHeader.querySelector('.arrow') : null;

            if (floatingChatbotContent && floatingChatbotHeader && floatingChatbotArrow) {
                // The floating window itself will control visibility, so we ensure the internal content is always expanded
                floatingChatbotContent.classList.add('expanded');
                floatingChatbotArrow.classList.add('expanded'); // Make arrow point up by default for the internal content

                // Keep the internal expander functionality, but it will control internal scroll height, not main window visibility.
                floatingChatbotHeader.addEventListener('click', () => {
                    floatingChatbotContent.classList.toggle('expanded');
                    floatingChatbotArrow.classList.toggle('expanded');
                    if (floatingChatbotContent.classList.contains('expanded') && chatWindow) {
                        chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom when content expands
                    }
                });
            }
        });
    </script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: predictor.py ---

# predictor.py

import datetime
import pandas as pd # Ensure pandas is imported

# Removed redundant imports (fetch_ohlcv, add_technical_indicators, get_current_price, get_bitcoin_sentiment)
# as these functions will now receive the necessary data (df, current_price, sentiment_score)
# directly from the calling backend_app.py

def predict_future_price(df: pd.DataFrame, current_price: float, hours_ahead: float = 1):
    """
    Predicts the future price based on historical price changes.

    Args:
        df (pd.DataFrame): DataFrame containing historical OHLCV data, specifically 'close' prices.
        current_price (float): The current BTC price.
        hours_ahead (float): The number of hours into the future to predict.

    Returns:
        tuple: (projected_price, average_delta_per_hour, current_price)
    """
    if df.empty or 'close' not in df.columns or len(df) < 2:
        # Not enough data to calculate price changes, return current price as projected
        print("Warning: Not enough data in DataFrame for accurate price prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Ensure 'close' column is numeric
    df_numeric_close = pd.to_numeric(df['close'], errors='coerce').dropna()
    if df_numeric_close.empty or len(df_numeric_close) < 2:
        print("Warning: 'close' column has insufficient numeric data for prediction. Returning current price as projected.")
        return current_price, 0.0, current_price

    # Calculate average price movement per hour from the historical data
    price_changes = df_numeric_close.diff().dropna()
    
    avg_delta = price_changes.mean() if not price_changes.empty else 0.0

    projected_price = current_price + (avg_delta * hours_ahead)

    return round(projected_price, 2), round(avg_delta, 2), current_price

def recommend_probo_vote_for_target(df: pd.DataFrame, current_price: float, sentiment_score: float, target_price: float, target_time_str: str):
    """
    Recommends a 'YES' or 'NO' vote for a Probo outcome based on projected price and sentiment.

    Args:
        df (pd.DataFrame): DataFrame containing historical OHLCV data.
        current_price (float): The current BTC price.
        sentiment_score (float): The current Bitcoin sentiment score.
        target_price (float): The target price for the Probo outcome.
        target_time_str (str): The target time in "HH:MM" format (UTC).

    Returns:
        dict: A dictionary containing prediction details and the recommended vote.
    """
    # 1. Parse time and calculate hours remaining
    now_utc = datetime.datetime.utcnow()
    
    # Parse target_time_str (which is expected to be HH:MM in UTC from backend)
    target_time_only = datetime.datetime.strptime(target_time_str, "%H:%M").time()
    
    # Combine today's UTC date with target time
    target_datetime_utc = now_utc.replace(hour=target_time_only.hour, minute=target_time_only.minute, second=0, microsecond=0)
    
    # If target time has already passed today (UTC), assume it's for tomorrow
    if target_datetime_utc < now_utc:
        target_datetime_utc += datetime.timedelta(days=1)

    hours_remaining = (target_datetime_utc - now_utc).total_seconds() / 3600
    hours_remaining = max(0.25, round(hours_remaining, 2))  # Minimum 15 min window (0.25 hours)

    # 2. Use passed sentiment
    sentiment = sentiment_score

    # 3. Predict price using the provided df and current_price
    projected, delta, current = predict_future_price(df, current_price, hours_remaining)

    # 4. Decision logic
    # Vote 'YES' if projected price meets or exceeds target AND sentiment is not strongly negative
    if projected >= target_price and sentiment >= -0.1:
        vote = "YES"
    else:
        vote = "NO"

    # 5. Return analysis
    result = {
        "current_price": current,
        "avg_delta_per_hour": delta,
        "hours_remaining": hours_remaining,
        "projected_price": projected,
        "sentiment": sentiment,
        "target_price": target_price,
        "target_time": target_time_str, # Keep the original HH:MM string for display
        "vote": vote
    }

    return result

if __name__ == "__main__":
    # This block is for local testing of predictor.py's functions
    # In a real application, these functions are called by backend_app.py
    print("--- Testing predictor.py (requires mock data) ---")
    
    # Example of how to test locally (uncomment and run if needed)
    # from btc_data import fetch_ohlcv, add_technical_indicators, get_current_price
    # from sentiment import get_bitcoin_sentiment

    # print("Fetching mock data for local predictor test...")
    # df_test = fetch_ohlcv(limit=50) # Fetch some data
    # df_test = add_technical_indicators(df_test) # Add indicators
    # current_price_test = get_current_price() # Get current price
    # sentiment_test = get_bitcoin_sentiment() # Get sentiment

    # if not df_test.empty and current_price_test > 0:
    #     target_price_test = current_price_test + 500 # Example target
    #     target_time_test = (datetime.datetime.utcnow() + datetime.timedelta(hours=2)).strftime("%H:%M") # 2 hours from now UTC

    #     question = recommend_probo_vote_for_target(
    #         df=df_test,
    #         current_price=current_price_test,
    #         sentiment_score=sentiment_test,
    #         target_price=target_price_test,
    #         target_time_str=target_time_test
    #     )
        
    #     print("\nüß† Prediction Summary (Local Test):")
    #     for k, v in question.items():
    #         print(f"{k.replace('_', ' ').title()}: {v}")
    # else:
    #     print("Could not fetch sufficient data for local predictor test.")



--- END FILE: predictor.py ---

--- START FILE: probo_strategy.py ---

# probo_strategy.py

import pandas as pd
import numpy as np # Import numpy to check for NaN

def interpret_market_conditions(df: pd.DataFrame):
    """
    Interprets market conditions based on technical indicators (RSI, EMA)
    and new volatility/price movement metrics.

    Args:
        df (pandas.DataFrame): DataFrame with 'RSI', 'EMA_20', 'EMA_50',
                               'body_size', 'candle_range', 'wick_to_body_ratio' columns.

    Returns:
        dict: A dictionary containing interpreted market conditions.
    """
    required_cols = ['RSI', 'EMA_20', 'EMA_50', 'body_size', 'candle_range', 'wick_to_body_ratio', 'close']
    if df.empty or not all(col in df.columns for col in required_cols):
        print("Warning: DataFrame is empty or missing required columns for market interpretation. Returning default conditions.")
        return {
            "bullish_trend": False,
            "oversold": False,
            "overbought": False,
            "rsi": 50.0,
            "ema_20": 0.0,
            "ema_50": 0.0,
            "massive_move_recent": False, # New default
            "candle_volatility_high": False, # New default
            "candle_bodies_stable": False # New default
        }

    # Get the latest values
    latest = df.iloc[-1]

    # Convert numpy types to standard Python types and handle NaN
    rsi = float(latest["RSI"]) if pd.notna(latest["RSI"]) else None
    ema_20 = float(latest["EMA_20"]) if pd.notna(latest["EMA_20"]) else None
    ema_50 = float(latest["EMA_50"]) if pd.notna(latest["EMA_50"]) else None
    
    # New metrics
    latest_close = float(latest["close"]) if pd.notna(latest["close"]) else None
    latest_body_size = float(latest["body_size"]) if pd.notna(latest["body_size"]) else None
    latest_candle_range = float(latest["candle_range"]) if pd.notna(latest["candle_range"]) else None
    latest_wick_to_body_ratio = float(latest["wick_to_body_ratio"]) if pd.notna(latest["wick_to_body_ratio"]) else None

    # Trend signal: EMA20 > EMA50 generally indicates an uptrend
    bullish_trend = bool(ema_20 is not None and ema_50 is not None and ema_20 > ema_50)
    
    # RSI zones
    oversold = bool(rsi is not None and rsi < 30)
    overbought = bool(rsi is not None and rsi > 70)

    # --- Automated Analysis for previously manual checks ---

    # 1. "BTC just made a massive move"
    # Check for a significant percentage change over the last few candles (e.g., last 4 hours)
    massive_move_recent = False
    if len(df) >= 4 and latest_close is not None:
        # Calculate percentage change over the last 4 hours (or fewer if less data)
        past_close = df['close'].iloc[-4] if len(df) >= 4 else df['close'].iloc[0]
        if pd.notna(past_close) and past_close != 0:
            percent_change = abs((latest_close - past_close) / past_close) * 100
            # Define "massive" as, for example, > 2% move in 4 hours
            if percent_change > 2.0: # Threshold for a "massive move"
                massive_move_recent = True

    # 2. "Candle volatility is high (huge wicks)" / "Candle bodies are stable (not huge wicks)"
    candle_volatility_high = False
    candle_bodies_stable = False

    if latest_wick_to_body_ratio is not None and latest_body_size is not None and latest_candle_range is not None:
        # High volatility: high wick-to-body ratio OR large total candle range relative to price
        # Thresholds are examples and might need tuning
        if latest_wick_to_body_ratio > 1.5 or (latest_candle_range / latest_close) * 100 > 1.0: # Example: wicks 1.5x body, or 1% range
            candle_volatility_high = True
        
        # Stable bodies: small wick-to-body ratio AND decent body size (not a doji)
        # Assuming 'stable' means not too small (doji) and not dominated by wicks
        if latest_wick_to_body_ratio < 0.5 and (latest_body_size / latest_close) * 100 > 0.1: # Example: wicks < 0.5x body, body > 0.1% of price
            candle_bodies_stable = True
    
    # If volatility is high, then bodies are NOT stable. These are often mutually exclusive.
    # Prioritize volatility if detected.
    if candle_volatility_high:
        candle_bodies_stable = False # If high volatility, bodies are not stable

    return {
        "bullish_trend": bullish_trend,
        "oversold": oversold,
        "overbought": overbought,
        "rsi": rsi,
        "ema_20": ema_20,
        "ema_50": ema_50,
        "massive_move_recent": massive_move_recent,
        "candle_volatility_high": candle_volatility_high,
        "candle_bodies_stable": candle_bodies_stable
    }

# The recommend_probo_vote function below is likely for standalone testing
# or was part of a previous Streamlit app. It is not directly called by the Flask backend
# in the current design, as the prediction logic is handled by backend_app.py calling predictor.py.
def recommend_probo_vote():
    """
    (Deprecated for Flask backend usage)
    Recommends a Probo vote based on market conditions and sentiment.
    This function is more suitable for a standalone script or a Streamlit app.
    For the Flask backend, individual components (fetch_ohlcv, add_technical_indicators,
    get_current_price, get_bitcoin_sentiment, interpret_market_conditions) are called
    and their results are used to build the prediction.
    """
    from btc_data import fetch_ohlcv, add_technical_indicators, get_current_price
    from sentiment import get_bitcoin_sentiment

    print("[+] Fetching market data...")
    df = fetch_ohlcv()
    if df.empty:
        print("Failed to fetch OHLCV data. Cannot recommend vote.")
        return "N/A"

    df = add_technical_indicators(df)
    market = interpret_market_conditions(df)
    price = get_current_price()

    print("[+] Analyzing sentiment...")
    sentiment_score = get_bitcoin_sentiment()

    print("\nüìä BTC Market Snapshot")
    print(f"Price: ${price:.2f}")
    # Handle None values for display
    rsi_display = f"{market['rsi']:.2f}" if market['rsi'] is not None else "N/A"
    ema20_display = f"{market['ema_20']:.2f}" if market['ema_20'] is not None else "N/A"
    ema50_display = f"{market['ema_50']:.2f}" if market['ema_50'] is not None else "N/A"
    print(f"RSI: {rsi_display} | EMA20: {ema20_display} | EMA50: {ema50_display}")
    sentiment_status = 'Bullish' if sentiment_score > 0 else 'Bearish' if sentiment_score < 0 else 'Neutral'
    print(f"Sentiment Score: {sentiment_score:.3f} ({sentiment_status})")

    # Decision logic (simplified for this example)
    vote = "NO"
    if market["bullish_trend"] and sentiment_score > 0.1:
        vote = "YES"
    elif market["oversold"] and sentiment_score > -0.05:
        vote = "YES"
    elif market["overbought"] and sentiment_score < -0.1:
        vote = "NO"

    print(f"\nüß† Probo Recommendation: ‚úÖ Vote {vote}")
    return vote

if __name__ == "__main__":
    print("--- Running standalone Probo Strategy Recommendation ---")
    recommend_probo_vote()


--- END FILE: probo_strategy.py ---

--- START FILE: README.md ---

Website Link : https://probo-crypto-predictor.netlify.app/


--- END FILE: README.md ---

--- START FILE: requirements.txt ---

pandas
requests
plotly
ta
feedparser
textblob
flask
flask-cors
gunicorn
pytz
numpy
prophet
google-generativeai # For Gemini API
Pillow # For image processing (though `google-generativeai` might handle basic bytes)
# If you decide to implement full PDF/DOCX/XLSX parsing, you'll need:
PyPDF2 # For PDF text extraction
python-docx # For .docx text extraction
openpyxl # For .xlsx text extraction

--- END FILE: requirements.txt ---

--- START FILE: sentiment.py ---

# sentiment.py

import feedparser
from textblob import TextBlob
import urllib.parse
# Removed: import streamlit as st

def fetch_news_sentiment(query="bitcoin", max_items=20):
    """
    Fetches news headlines for a given query from Google News RSS and calculates
    an average sentiment polarity using TextBlob.

    Args:
        query (str): The search query (e.g., "bitcoin").
        max_items (int): Maximum number of news items to process.

    Returns:
        float: Average sentiment polarity (between -1.0 and 1.0).
               Returns 0.0 if no headlines are found or an error occurs.
    """
    encoded_query = urllib.parse.quote(query)  # URL encode the query
    url = f"https://news.google.com/rss/search?q={encoded_query}"
    
    try:
        feed = feedparser.parse(url)
        headlines = [entry.title for entry in feed.entries[:max_items]]

        if not headlines:
            print(f"No news headlines found for query: '{query}'")
            return 0.0  # Neutral if no news

        sentiments = [TextBlob(headline).sentiment.polarity for headline in headlines]
        return round(sum(sentiments) / len(sentiments), 3)
    except Exception as e:
        print(f"Error fetching or analyzing news sentiment for '{query}': {e}")
        return 0.0 # Return neutral sentiment on error

# Removed: @st.cache_data(ttl=600) decorator as it's Streamlit-specific
def get_bitcoin_sentiment():
    """
    Gets the sentiment score specifically for Bitcoin.
    """
    return fetch_news_sentiment("bitcoin OR btc")

if __name__ == "__main__":
    print("--- Testing sentiment.py ---")
    sentiment = get_bitcoin_sentiment()
    print(f"Bitcoin Sentiment Score: {sentiment}")
    if sentiment > 0:
        print("Market sentiment is positive.")
    elif sentiment < 0:
        print("Market sentiment is negative.")
    else:
        print("Market sentiment is neutral or could not be determined.")



--- END FILE: sentiment.py ---

--- START FILE: site.webmanifest ---

{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}

--- END FILE: site.webmanifest ---

--- START FILE: telegram_bot.py ---

# telegram_bot.py
import requests
import os

# Your bot token and user ID
# Get BOT_TOKEN from environment variable
# IMPORTANT: Replace "YOUR_FALLBACK_TOKEN_IF_NOT_SET" with a dummy value
# but ensure you set the actual environment variable in your deployment environment.
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "YOUR_FALLBACK_TOKEN_IF_NOT_SET")
USER_ID = os.environ.get("TELEGRAM_USER_ID", 5368095453) # Or keep your numeric ID if it's constant

def send_telegram_alert(message):
    """
    Sends a Markdown-formatted message as an alert to a specified Telegram user.

    Args:
        message (str): The message content to send.
    """
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_FALLBACK_TOKEN_IF_NOT_SET":
        print("‚ùå Telegram BOT_TOKEN not configured. Alert not sent. Please set the TELEGRAM_BOT_TOKEN environment variable.")
        return
    
    if not USER_ID:
        print("‚ùå Telegram USER_ID not configured. Alert not sent. Please set the TELEGRAM_USER_ID environment variable.")
        return

    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": USER_ID,
        "text": message,
        "parse_mode": "Markdown" # Allows bold, italics, etc.
    }
    try:
        response = requests.post(url, json=payload, timeout=10) # Add timeout
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        if response.status_code == 200:
            print("‚úÖ Telegram alert sent successfully.")
        else:
            print(f"‚ùå Failed to send alert (status code: {response.status_code}): {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Telegram alert error (network/request issue): {str(e)}")
    except Exception as e:
        print(f"‚ùå An unexpected error occurred while sending Telegram alert: {str(e)}")

# Test message
if __name__ == "__main__":
    print("--- Testing telegram_bot.py ---")
    # For local testing, you MUST set the environment variables in your terminal
    # before running this script. Example:
    # export TELEGRAM_BOT_TOKEN="YOUR_ACTUAL_BOT_TOKEN_HERE"
    # export TELEGRAM_USER_ID="YOUR_ACTUAL_USER_ID_HERE"
    
    test_message = "üö® *Test Alert* from BTC Probo Predictor! If you see this, the bot is working."
    send_telegram_alert(test_message)



--- END FILE: telegram_bot.py ---

--------------------------------------------------------------------------------------------

the view chart is not showing the chart why? fix that, it's showing a blank axis with indicators, no graphs there. improve the design of the floating ai chatbot. guide me through the deployment process, the frontend is deployed on netlify and the backend is on render.